#+SEQ_TODO: TODO NEXT INPR WAIT NOPE DONE

* Timeline/Snippets
  everything will take 2x as long ==> 6 months :D
*** DONE [3/3] week 1: Getting started
    CLOSED: [2019-01-30 Wed 17:52]
******* DONE read Seyedali's documentation
        CLOSED: [2019-01-20 Sun 12:07]
        ==> background brain
******* DONE read NetFPGA documentation
        CLOSED: [2019-01-22 Tue 11:32]
        [[*SDNet + P4-SDNet]]
******* DONE set up repo skeleton
        CLOSED: [2019-01-23 Wed 16:39]
*** DONE [4/4] week 2
    CLOSED: [2019-02-05 Tue 18:49]
***** DONE Figure out the project structure
      CLOSED: [2019-01-29 Tue 18:43]
***** DONE Make things compile with the new repo structure
      CLOSED: [2019-02-04 Mon 15:28]
***** DONE get some SCION packets
      CLOSED: [2019-01-23 Wed 19:35]
      captured stuff from my SCION VM, lives in testdata/*.pcap
***** Made significant progress on [[*Write the parser][Write the parser]], but...
***** DONE NEW! Terrible terrible things: see [[*P4 spec compatibility (or lack thereof)][P4 spec compatibility (or lack thereof)]]
      Will talk to Benjamin on <2019-02-05 Tue>. Tentative plan for next weeks follows.
*** NEXT [1/4] week 3: Figure out the parser despite setbacks
***** DONE Figure out how to create custom architectures
      CLOSED: [2019-02-05 Tue 18:43]
      Currently there's no way to do that: the architectures are built into the
      compiler, and I don't have the Xilinx compiler's source code.

      I can hopefully use XilinxStreamSwitch with a bit of poking at the Verilog
      wrapper module.
***** NOPE Create a ~packet_mod~-enabled architecture
      Equivalent to SimpleSumeSwitch but with packet_mod for the deparser.
      Rejected because not possible; will use ~XilinxStreamSwitch~.
***** INPR [2/6] Write the parser
      With the fancy idea for using ~packet_mod~ if possible and variable-length
      fields in a "skip" struct otherwise.
******* DONE Parse SCION Common Header
        CLOSED: [2019-02-02 Sat]
******* DONE Parse SCION Address Header
        CLOSED: [2019-02-05 Tue 18:44]
        The 8-byte alignment was super annoying because SDNet.
******* NEXT Parse current SCION Info Field
******* TODO Parse current SCION Hop Field + next HF if VRFY_ONLY
******* TODO [0/2] Write the deparsers
********* TODO "normal" deparser
********* TODO ~packet_mod~ deparser
******* NEXT Test it
***** WAIT Make it possible to use ~XilinxStreamSwitch~ on the NetFPGA
      Stuck on not having the SDNet license. Sniff sniff.
      I really hope this will work.
*** week 4: implement a small subset of SCION forwarding          :dataplane:
    so we have something to play with
*** [0/4] week 5: implement SCION path verification ==> AES       :dataplane:
***** TODO find 3rd party AES module                                    :aes:
      make it easily replaceable with commercial solutions
      ==> don't worry about side channels (not my problem) :D
***** TODO add AES as an extern to P4
***** TODO test that AES works                                          :aes:
***** TODO wire it together: implement and test path verification :dataplane:
*** [0/1] weeks 6-7: complete SCION forwarding                    :dataplane:
***** [1/4] Deploy (existing) P4 router                             :intraAS:
******* DONE find the router
        CLOSED: [2019-01-22 Tue 11:46]
        https://github.com/p4lang/switch
******* TODO figure out which parts we want and split them out
******* TODO stuff it in
******* TODO test it
***** TODO evaluate it: does it work?
      how?
*** week 8: re-structure the code properly [0/1]
***** TODO put the parts that should be easy to switch into separate files:
      Right now I separate by function (parsers, headers, etc). I should be
      separating by concern (intra-AS, inter-AS, ...).
       - SCION encapsulation
       - IP stack
       - SCION core
*** [/] weeks 9-12: Performance                                   :dataplane:
    How fast is it? Where are the bottlenecks? Can we make it faster?
***** TODO see [[*Custom architecture]]
*** [/] week 13: deploy in production
* Questions for Benjamin
*** TODO [[P4 spec compatibility (or lack thereof)]]
*** TODO Should we also add an "L2 learning switch"?
    ARP + remembering MAC addresses

*** Archive:
***** DONE Is Scion *always* encapsulated? And is it always in IP/UDP?
      CLOSED: [2019-01-30 Wed 18:48]
      for now yes; eventually no
***** DONE => What is expected of me? What packets should I be able to process?
      CLOSED: [2019-01-30 Wed 14:58]
      this can also go into thesis/documentation
      SCION only
***** DONE what to do about packets which aren't SCION?
      CLOSED: [2019-01-30 Wed 14:59]
      for now drop is good
***** DONE LICENSE?
      CLOSED: [2019-01-30 Wed 14:59]
      check scion repo
* Questions about FPGAs
*** DONE VHDL vs Verilog: what's the relationship?
    CLOSED: [2019-01-23 Wed 11:05]
    Both are hardware description languages. VHDL smells a little more like Ada
    and Verilog smells a little more like C. As far as I can tell, Verilog is
    slightly more popular in FPGA circles. Most Xilinx tooling will be using
    Verilog.

    You can combine modules written in either as long as you know what the
    interfaces are. A bit like you can link things written in different
    languages in software too.
*** DONE How do you do modular design? Literally "LEGO submodules"?
    CLOSED: [2019-01-23 Wed 11:05]
    Generally, you will want a bus like AMBA or Axi and your modules will talk
    to each other on the bus using well-defined protocols.
*** DONE What does IP stand for in FPGA context?
    CLOSED: [2019-01-20 Sun 11:42]
    "intelectual property core" ==> something that you buy from someone else and
    integrate in your design.

    Can be pronounced "module" or even "chip".

    Blocks may be more or less independent. You could add e.g. a microblaze cpu
    to your design. It will have its own clock domains and talk to other modules
    using memory. Or you might have something like AES which operates in your
    data path.
*** TODO Gimme a nice paper about implementing something on an FPGA in a nice way.
    So that I can do my learning by example thing.
*** TODO What's this thing about 8 bytes? How general is it?
*** DONE How do I find out if it's optimal?
    CLOSED: [2019-01-23 Wed 11:08]
    This P4 stuff will compile into something that will light up different parts
    of the FPGA at different times. I want to:
      - look at it
      - figure out whether it could be parallelising some more
      - tell it to do better (maybe :D)

    Supposedly the Vivado tools help with that. I should revisit this once I get
    the license crap to work.
* HW documentation
*** SDNet + P4-SDNet
    downloaded from: https://www.xilinx.com/products/design-tools/software-zone/sdnet.html#documentation
     1. Read this first: [[./hw-doc/ug1252-p4-sdnet.pdf][P4-SDNet]]
     2. Read this when you want to make your own externs: [[./hw-doc/ug1012-sdnet-packet-processor.pdf][SDNet]]
* Ideas to revisit when the time comes
*** Custom architecture
    Instead of sticking with the =SimpleSUMESwitch(parser, pipeline, deparser)=
    architecture, it might be useful to define a custom architecture designed
    specifically for SCION. This might be for example something like:
    #+begin_src p4_16
    ScionSUMESwitch(
        my_parser,
        my_path_verification,
        my_pipeline,
        my_deparser
    )
    #+end_src

    ...Or maybe (this might be a terrible idea): explicitly separate the
    intra-AS and inter-AS thing:
    #+begin_src p4_16
    ScionSUMESwitch(
        my_intraAS_parser,     // handles the intra-AS encapsulation: in our case, IP + UDP (but could be e.g. MPLS for other ASs)
        my_scion_parser,       // parses the SCION header
        my_path_verification,  // read-only; handles the path verification
        my_pipeline,           // updates the "next segment" pointers and picks the output port
        my_scion_deparser      // deparses the SCION header
        my_intraAS_deparser    // adds the intra-AS encapsulation
    )
    #+end_src
    (For this case we might want a hardcoded component that dispatches to the
    intra-AS en/decapsulation only if needed ==> gets non-trivial. So that's why
    it's maybe a terrible idea)

    Before spending time on this, I should:

***** TODO find out whether there actually are performance advantages to custom architectures
***** TODO talk to people about whether this is a good idea and what is a good architecture
*** Eventual code-related TODOs:
***** TODO README files everywhere
      every directory should have a README file
      (maybe generated? :-o)
***** TODO LICENSE files everywhere
      check SCION repo for which
***** TODO [0/2] Optimisation
******* TODO check all parameters: in/out/inout
******* TODO check all parameters: are they actually used?
        actually, first check whether the compiler warns for unused
* Notes to self
*** about NetFPGA
***** Annotations:
       apparently there is a pile of @Xilinx_whatever annotations which look
       like they affect how the things are laid out on the FPGA
       ==> documented in P4-SDNet
***** Architecture:
      #+BEGIN_SRC p4_16
      SimpleSumeSwitch(
          TopParser(),
          TopPipe(),
          TopDeparser()
      ) main;
      #+END_SRC
***** Registers:
      Accessing registers doesn't exist :D
      They have an extern which is one function where an argument says whether
      it's a read or a write, and there is just one register:
      #+begin_src p4_16
      const_reg_rw(
          index,
          value_to_be_written, // probably bit<
          r_or_w,  // bit<8>
          value_will_be_read_into_here
      );
      #+end_src
      Actually this is a bit weird and confusing.
***** Testing things
      You generate pcap files with input packets and expected
      output packets. (Not sure if the expected packets are an exact match or
      what.)

      The neat thing about that: there's a pcap2axi thing, so the packets are
      replayed from memory. Therefore...
***** Performace testing
      Just make a big pcap file :D ^^
***** Turning source code into bits in the FPGA
       1. ~p4c-sdnet~ converts P4 into the SDNet language, which is a Xilinx
          thing that looks a little like C++. Check out .sdnet files.
          Makefile target: ~sdnet~
       2. ~sdnet~ compiles the .sdnet file into a module/IP core that then
          goes into Vivado. I can pick the bus type as a compiler flag (sample
          project makefile has Axi).
          Makefile target: ~module~ (doesn't exist yet, TODO)
          From now on it's the usual FPGA workflow.
       3. TODO Figure out what to do with it once it's in Vivado.
          Probably something like ~synth~, route & place, ~bitfile~...
***** TODO How do custom architectures work?
*** documentation
***** TODO SCION Parser
***** TODO portability
* Things to write about
*** Aim: SCION BR
    => only SCION
*** Intro to FPGAs for software people
***** TODO think in space, not time
       - everything happens at the same time
       - TODO didn't I start writing this down somewhere else? either tiddlywiki or website :D -- find it!
***** TODO resources / limiting factors
       - Area instead of # of instructions
*** why I am being awesome (TODO also make it true :D)
***** modularity:
******* easy to swap things in here with other stuff (e.g. replace IP with MPLS)
******* easy to take things from here and put into your switch
******* easy to change functionality without being very sad because things are well separated
***** portability
       - runs on SDNet and v1model and the SCION code doesn't need to change to add a new arch
       - can benefit from features present only on some archs, but doesn't need much rewriting because of ~lib/compat~ and because modularity
***** attention to detail
       - by only passing the parameters I really need instead of the whole metadata or headers struct, I both enforce modularity *and* give the compiler more information about the code so that it can optimise better. TODO would be neat to have an example.
*** Challenges
***** P4 spec compatibility (or lack thereof)
Unfortunately, the SDNet P4 compiler implements only a subset of P4, which has
created unexpected challenges when implementing SCION.
The biggest issue [HOPEFULLY :D] was that at the time of writing, with P4-SDNet
the parser cannot parse any variable-length data: this includes not only
=varbit<n>= types, but also header unions, and -- most importantly -- header
stacks.
This poses a problem for SCION: the path in the packet is variable length (it
can contain any number of hops).[fn:varlen]
Therefore, the parser cannot parse the path in the SCION packet.[fn:cantparse]

A workaround (and additionally a performance improvement) is to parse only the
actually needed data: while the path can be arbitrarily long, any single BR only
needs to process $O(1)$ hop fields (usually one, or two in case of a shortcut
path). [TODO is that always true?]
This workaround cannot, however, be used as is: using only the standard features
of P4, it is impossible to deparse parts of the header which have not been
parsed. (The payload is copied without being parsed, but the payload is defined
as anything *after* the last thing we parsed -- so if we skip parsing something
in the header, it is lost and we are unable to emit it on the output interface.)

The solution is to use the non-standard ~packet_mod~ feature of P4-SDNet, as
this (unlike the standard deparsers) allows to modify the existing header
instead of creating it anew, thereby allowing me to not lose the skipped parts
of the header.

Using this feature was not straightforward, either: we needed to create a custom
architecture, as this feature is not available in the ~SimpleSumeSwitch~
architecture that is the default on the NetFPGA.
The custom architecture we created is described [SOMEWHERE ELSE].

Obviously, using a non-standard SDNet-only feature means that with this
approach, the program would not compile on a standard P4 compiler.
However, standard P4 compilers (unlike the P4-SDNet compiler) tend to implement
parsing variable-length headers.
Therefore, we are able to emulate ~packet_mod~ for standard compilers by adding
an extra struct to keep track of the "skipped" parts of the headers, and instead
of skipping them, we parse them into the (variable-length) fields of this extra
struct.

We can use preprocessor macros to hide this difference, thereby keeping our
code portable while being able to use ~packet_mod~ where available.
This not only allows us to parse the variable-length SCION packet on the
currently incomplete P4-SDNet compiler, but also allows us to harness the
performance benefits of the ~packet_mod~ feature on any target where it is
available.


[fn:varlen] The SCION host addresses are also variable-length, as the address
type tag in the common header defines what kind of address it is.
For this case, we opted to use the C preprocessor to conditionally replace the
union with a struct with three fixed-length fields (one for each possible type
of address), only one of which is parsed and made valid for a given packet.
(This causes a small increase in FPGA area usage, but any other solution would
be significantly more complex, so this is a good tradeoff.)

[fn:cantparse] In fact, it would be possible to parse the whole SCION packet by
using the C preprocessor to "unroll" the parser at compile time, and parse the
path segments into ~struct~'s with fields such as =hop1=, =hop2=, ... (size
fixed at compile time).
However, this would make actually using the fields very difficult, as I would
need more preprocessor magic to index into such a struct; and additionally it
would drastically increase my FPGA area usage.
