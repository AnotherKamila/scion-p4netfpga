#+SEQ_TODO: TODO NEXT DONE

* Timeline/Snippets
  everything will take 2x as long ==> 6 months :D
*** week 1
***** [3/3] Getting started
******* DONE read Seyedali's documentation
        CLOSED: [2019-01-20 Sun 12:07]
        ==> background brain
******* DONE read NetFPGA documentation
        CLOSED: [2019-01-22 Tue 11:32]
        [[*SDNet + P4-SDNet]]
******* DONE set up repo skeleton
        CLOSED: [2019-01-23 Wed 16:39]
***** [1/3] write the SCION packet parser
******* DONE get some SCION packets
        CLOSED: [2019-01-23 Wed 19:35]
        captured stuff from my SCION VM, lives in testdata/*.pcap
******* NEXT write the parser
******* TODO test it
*** week 2
***** [0/1] Getting started 2
******* TODO complete & run & test one of the tutorial NetFPGA projects
        Doing =switch_calc=
********* 0. Artillery Preparation
           1. Edit ~~/projects/P4-NetFPGA-live/tools/settings.sh~
           2. open tmux
           3. ~. ~/envsetup.sh~
           4. ~cd $P4_PROJECT_DIR~
           5. (in my emacs) ~e /scion-netfpga:...~ (will be in recent files next time)

***** [1/4] Deploy (existing) P4 router                             :intraAS:
******* DONE find the router
        CLOSED: [2019-01-22 Tue 11:46]
        https://github.com/p4lang/switch
******* TODO figure out which parts we want and split them out
******* TODO stuff it in
******* TODO test it
*** [/] week 3: implement a small subset of SCION forwarding      :dataplane:
    so we have something to play with
*** [0/4] week 4: implement SCION path verification ==> AES       :dataplane:
***** TODO find 3rd party AES module                                    :aes:
      make it easily replaceable with commercial solutions
      ==> don't worry about side channels (not my problem) :D
***** TODO add AES as an extern to P4
***** TODO test that AES works                                          :aes:
***** TODO wire it together: implement and test path verification :dataplane:
*** [0/1] weeks 5-7: complete SCION forwarding                    :dataplane:
***** TODO evaluate it: does it work?
      how?
*** week 8: re-structure the code properly [0/1]
***** TODO put the parts that should be easy to switch into separate files:
      Right now I separate by function (parsers, headers, etc). I should be
      separating by concern (intra-AS, inter-AS, ...).
       - SCION encapsulation
       - IP stack
       - SCION core
*** [/] weeks 9-12: Performance                                   :dataplane:
    How fast is it? Where are the bottlenecks? Can we make it faster?
***** TODO see [[*Custom architecture]]
*** [/] week 13 (if feeling hyperactive): deploy in production
* Questions about FPGAs
*** DONE VHDL vs Verilog: what's the relationship?
    CLOSED: [2019-01-23 Wed 11:05]
    Both are hardware description languages. VHDL smells a little more like Ada
    and Verilog smells a little more like C. As far as I can tell, Verilog is
    slightly more popular in FPGA circles. Most Xilinx tooling will be using
    Verilog.

    You can combine modules written in either as long as you know what the
    interfaces are. A bit like you can link things written in different
    languages in software too.
*** DONE How do you do modular design? Literally "LEGO submodules"?
    CLOSED: [2019-01-23 Wed 11:05]
    Generally, you will want a bus like AMBA or Axi and your modules will talk
    to each other on the bus using well-defined protocols.
*** DONE What does IP stand for in FPGA context?
    CLOSED: [2019-01-20 Sun 11:42]
    "intelectual property core" ==> something that you buy from someone else and
    integrate in your design.

    Can be pronounced "module" or even "chip".

    Blocks may be more or less independent. You could add e.g. a microblaze cpu
    to your design. It will have its own clock domains and talk to other modules
    using memory. Or you might have something like AES which operates in your
    data path.
*** TODO Gimme a nice paper about implementing something on an FPGA in a nice way.
    So that I can do my learning by example thing.
*** TODO What's this thing about 8 bytes? How general is it?
*** DONE How do I find out if it's optimal?
    CLOSED: [2019-01-23 Wed 11:08]
    This P4 stuff will compile into something that will light up different parts
    of the FPGA at different times. I want to:
      - look at it
      - figure out whether it could be parallelising some more
      - tell it to do better (maybe :D)

    Supposedly the Vivado tools help with that. I should revisit this once I get
    the license crap to work.
* HW documentation
*** SDNet + P4-SDNet
    downloaded from: https://www.xilinx.com/products/design-tools/software-zone/sdnet.html#documentation
     1. Read this first: [[./hw-doc/ug1252-p4-sdnet.pdf][P4-SDNet]]
     2. Read this when you want to make your own externs: [[./hw-doc/ug1012-sdnet-packet-processor.pdf][SDNet]]
* Ideas to revisit when the time comes
*** Custom architecture
    Instead of sticking with the ~SimpleSUMESwitch(parser, pipeline, deparser)~
    architecture, it might be useful to define a custom architecture designed
    specifically for SCION. This might be for example something like:
    #+begin_src p4_16
    ScionSUMESwitch(
        my_parser,
        my_path_verification,
        my_pipeline,
        my_deparser
    )
    #+end_src

    ...Or maybe (this might be a terrible idea): explicitly separate the
    intra-AS and inter-AS thing:
    #+begin_src p4_16
    ScionSUMESwitch(
        my_intraAS_parser,     // handles the intra-AS encapsulation: in our case, IP + UDP (but could be e.g. MPLS for other ASs)
        my_scion_parser,       // parses the SCION header
        my_path_verification,  // read-only; handles the path verification
        my_pipeline,           // updates the "next segment" pointers and picks the output port
        my_scion_deparser      // deparses the SCION header
        my_intraAS_deparser    // adds the intra-AS encapsulation
    )
    #+end_src
    (For this case we might want a hardcoded component that dispatches to the
    intra-AS en/decapsulation only if needed ==> gets non-trivial. So that's why
    it's maybe a terrible idea)

    Before spending time on this, I should:

***** TODO find out whether there actually are performance advantages to custom architectures
***** TODO talk to people about whether this is a good idea and what is a good architecture

* Notes to self
*** about NetFPGA
     - apparently there is a pile of @Xilinx_whatever annotations which look
       like they affect how the things are laid out on the FPGA
       ==> documented in P4-SDNet
     - the architecture is:
       #+BEGIN_SRC p4_16
       SimpleSumeSwitch(
           TopParser(),
           TopPipe(),
           TopDeparser()
       ) main;
       #+END_SRC
     - Accessing registers doesn't exist :D
       They have an extern which is one function where an argument says whether
       it's a read or a write, and there is just one register:
       #+begin_src p4_16
       const_reg_rw(
           index,
           value_to_be_written, // probably bit<
           r_or_w,  // bit<8>
           value_will_be_read_into_here
       );
       #+end_src
       Actually this is a bit weird and confusing.
     - Testing things: you generate pcap files with input packets and expected
       output packets. (Not sure if the expected packets are an exact match or
       what.)

       The neat thing about that: there's a pcap2axi thing, so the packets are
       replayed from memory. Therefore...
     - Performace testing: just make a big pcap file :D ^^
     - The ~p4c-sdnet~ simulator spits out a "module", I can pick the bus type
       as a compiler flag (sample project makefile has Axi)
