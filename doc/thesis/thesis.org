#+TITLE:  Line-rate packet forwarding for the SCION future Internet architecture
#+AUTHOR: Kamila Součková
#+DATE:   August 31, 2019
#+DESCRIPTION: Master Thesis
#+INCLUDE: thesis-setup.org

#+LATEX: \frontmatter
* [1/1] Abstract
  CLOSED: [2019-07-15 Mon 15:45]
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
  The SCION future Internet architecture is designed to provide route control,
  failure isolation, and explicit trust information for end-to-end communication.
  Its viability has already been demonstrated in production, but to work
  at Internet scale, it is necessary to make it perform at high speeds, reduce
  costs, and evaluate suitability for eventual implementation in hardware.
  This project implements a SCION border router capable of line-rate packet
  forwarding, currently running on an FPGA target.
  It uses P4: a new language for programming packet forwarding planes.
  This enables target independence, a quicker development cycle, and a more
  modular approach.
  Based on this work, we suggest changes to the SCION data plane that allow for
  more efficient processing in hardware.
* [0/1] Acknowledgements
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
  TODO
#+TOC: headlines 1
#+LATEX: \mainmatter

* [3/3] Introduction
  # [In field X, we still don’t understand Y & Z.]
  # Write a summary of the question(s) you are trying to answer.
  # What is the state of the world before your research came along?
  # Also, answer the harsh but important question: Who cares?
  # In writing this, you can start general, but make sure you clearly
  # define the “before” state of the world’s knowledge for the specific
  # area this paper is addressing.
*** DONE Why SCION?
    CLOSED: [2019-07-16 Tue 15:25]
    Today's Internet, based on IP and BGP, was conceived in a very different
    environment, with very different requirements and very different
    assumptions. Meant to be a research network, it assumed that
    access was not widespread (as only large institutions could afford a
    connection), that all entities connected to it trusted each other (and had
    out-of-band means to deal with misbehaviour),
    and that it would not grow large enough for outages to become difficult to
    manage.
    Considering these facts, it has scaled surprisingly well, but nowadays we
    are living in a very different world.

    Today, everyone is connected and everyone has their data on the Internet.
    With the huge number of connected entities, many of which have conflicting
    interests, trust can no longer be global and implicit.
    Users want control over their data, ISPs want control over their services,
    and states want to protect their infrastructure from outside actors.
    At this scale, convergence after path failure takes too long, and
    large-scale outages due to BGP route leaks are happening almost weekly.
    Furthermore, attacks on the Internet infrastructure, e.g. DDoS attack or BGP
    route hijacks, are becoming more and more common.
    In today's world, these issues can no longer be tolerated.

    In the future, the Internet will become even more critical. Automation (such
    as drones, self-driving cars, or remotely operated robots) will depend on
    the availability and security of the Internet.
    As more and more data moves online, trust will become even more of an issue.
    We will need ways to satisfy new requirements such as geo-fencing, which
    cannot be adequately fulfilled with the current Internet architecture.
    And as malicious actors get more and more sophisticated and powerful, their
    attacks will get even harder to stop.
    Therefore, we will need to move to an Internet architecture that is
    resilient to both unintentional failures and malicious attacks,
    can provide explicit trust information to the end users,
    and gives the end users as well as institutions control over whom they trust
    and what happens with their data.

    There have been may attempts to fix the IP+BGP-based Internet TODO[cite
    something], but patching an architecture designed with entirely different
    assumptions simply cannot solve all the problems TODO[cite something].
    Additionally, the IP-based approach also has scalability issues due to
    requiring very large routing tables, and this is bound to get worse in the
    future.
    Therefore, the SCION project chooses to build a clean-slate Internet
    architecture, with the goals of scalability, route control, failure
    isolation, and explicit trust information in the design.
*** DONE SCION right now
    CLOSED: [2019-07-16 Tue 17:16]
    Thanks to a well-thought-out design, as well as "real-life" considerations
    such as deployment, transition strategy, and engagement with industry, SCION
    is currently running in production in several locations TODO[cite].
    Additionally, a planet-wide research network for testing SCION is running
    thanks to SCIONLab TODO[cite SCIONLab paper].
    These use cases have proven that SCION is in fact suitable for real-world
    usage.
    In the near future, several ISPs are likely to start offering SCION
    connections to their customers.
    Therefore, considerations like throughput, cost-effectiveness, and energy
    efficiency are of great interest to many in the SCION community.

    The existing implementations of the SCION infrastructure, in particular the
    routers, run as applications on standard servers.
    This has enabled rapid development, as well as flexibility, and it will
    continue to be the primary approach until the protocol stabilises.
    However, with the current technologies, a software-based approach cannot
    achieve throughput above several tens of gigabits per second.
    Therefore, large-scale deployments would require many such routers, which is
    not cost-effective.
    From the research perspective, whether SCION can even in principle run at
    line rate, and what hurdles must be overcome, are still open questions.

    Especially thanks to the real-world deployments, SCION is now
    mature enough to lend itself to implementing in hardware.
    Though the current version of the protocol is very unlikely to be the final
    one, it would be useful to get an initial hardware-based implementation,
    mainly in order to evaluate the protocol's suitability for hardware.
    A successful hardware-based implementation would also be a good answer to
    the "can it run at line rate?" question, which would further increase the
    probability of deployment with commercial ISPs.
*** DONE Aims of this project
    CLOSED: [2019-07-18 Thu 13:37]
    TODO is this better inline like this, or in an item list?

    The first aim of this project is *implementing a border router capable of
    forwarding SCION packets at line rate*.
    We will target a NetFPGA SUME board, which will (in the ideal case) allow us
    to forward up to 40Gbps.
    The border router is the crucial building block of the SCION data plane.
    Therefore, having a high-speed prototype will open the doors to large-scale
    data transfers, as well as prove that infrastructure providers (such as
    ISPs) will be able to scale to meet the needs of many customers without
    incurring very high costs.

    Additionally, we wish to keep the work target-independent (as much as
    possible), and thereby create a "library for line-rate SCION" for a variety
    of targets and use-cases.

    An implementation targeting an FPGA[fn:1] is a good first step for
    evaluating the feasibility of building "SCION on chip": much of the design
    process is the same with FPGAs as with ASICs[fn:2].
    Therefore, the second aim of this work is to
    *confront SCION with hardware design expertise, and consider the possibility
    of building faster, more efficient designs in the future*.
    The knowledge gained in the process of implementation on the NetFPGA will
    allow us to better understand the requirements of running SCION in custom
    hardware, and predict whether a very high-speed and energy-efficient ASIC
    implementation could be built.
    As being able to run in hardware is a hard requirement for the success of
    any network-layer Internet protocol, knowing more about this question is
    crucial to the development and deployment of SCION.

    With the knowledge gained during the implementation, we will be able to
    fulfill the third aim of this project: *providing suggestions for the SCION
    protocol that would result in more efficient hardware implementations*.
    Running in hardware has been a consideration in the design of SCION from the
    beginning, but an actual implementation, rather than abstract reasoning, is
    likely to uncover opportunities for further improvement.
    Doing this early, before SCION has become widely deployed, allows us to
    implement any changes needed without having to worry about
    backwards-compatibility and enter the "real-life deployment" sphere with an
    already optimised protocol.
* [4/5] Background and Related Work
  In order to achieve this project's aims, we need to work in the intersection of
  several fields: among others network security, network protocols, software
  engineering, and hardware design.
  This chapter introduces what concerns us in each of the relevant areas, and the
  following chapters build on this information.
*** DONE SCION data plane
    CLOSED: [2019-07-23 Tue 17:47]
    SCION is a clean-slate Internet architecture designed for
    route control,
    failure isolation, and
    explicit trust information
    for end-to-end communication.
    For a comprehensive presentation of the SCION architecture, see cite:scion-book.
    In this section, I will introduce the aspects of the SCION data plane relevant
    for this work.
#+begin_comment Ain't nobody got time for this stuff
# The name SCION stands for "scalability, control, and isolation on
# next-generation networks", which summarises the aims of SCION: we will discuss
# below how these aims are achieved. First, let us have a look at how SCION works.
# ***** Overview of the SCION architecture
# ******* Isolation Domains
# At the core of SCION is the concept of *isolation domains* (ISDs): an ISD is
# an autonomous collection of ASes[fn:3] that manages its own routing
# infrastructure and root of trust (both for routing and PKI).
# Actors outside of the ISD are unable to influence either routing or trust within
# the ISD.
# The exact mapping of ISDs to physical world entities is a topic for further
# research, but for simplicity, we can imagine for the sake of this explanation
# that an ISD could map to a country or union of countries that share common
# jurisdiction and agreements.
# Multiple ASes within the ISDs run the *ISD core*, which is responsible for
# providing core routing infrastructure, as well as the PKI.
# These could be e.g. government-operated or large commercial ISPs.
# Non-core ASes then provide connectivity to end users, while relying on the
# services provided by the ISD core.
# The ISD is a self-contained entity, with everything needed for inter-ISD routing
# contained within the ISD.
# Therefore, the ISD is isolated from misconfiguration or misbehaviour by outside
# entites, which makes the network more stable and reliable.
# Furthermore, creating the hierarchy of separate ISDs instead of one global
# network helps with scalability, as described in TODO somewhere below.
# #+CAPTION: Multiple isolation domains (ISDs). Communication within each ISD is entirely handled within the ISD, and communication among different ISDs is facilitated by the ISD core. Note that while control plane communication always flows only among core ASes, inter-ISD data transfer is possible also over non-core links.
# #+NAME:   fig:isds
# [[./img/isds.png]]
# ******* Path discovery
# ******* Path selection
# ******* Packet forwarding
# The data plane blablabla.
#+end_comment
***** Packet-carried forwarding state
      In order to scale without the need for state on routers (specifically large
      routing tables), SCION puts all information needed for packet forwarding into
      the packet header.
      In particular, the user-selected path that the packet needs to take through the
      network is present in the header, as a stack of /hop fields/ (HFs).
      This means that the packet headers are variable-size and can be somewhat large
      -- this is the tradeoff SCION makes to avoid large and potentially inconsistent
      routing tables in routers.

      Each HF in the path corresponds to an AS-level hop.
      It encodes the ingress and egress interface in its AS,
      verification information used by the AS to check that the end host is
      allowed to use this hop,
      the expiration time for this HF (which must be checked),
      and some additional information.
      The exact HF format is described in TODO[ref SCION book].
      In order to forward the packet, the router only needs to look at the
      "current" HF, i.e. the one meant for this AS.
      Therefore, the SCION header contains a pointer to the current HF.
      This is initially set to the first one in the path, and every egress
      border router increments it after processing it, so that a router can find
      its HF without parsing the whole path.
***** Hop field verification
      Allowing the end host to assemble the path is great for giving the end
      host control, but for various reasons ASes may need to enforce routing
      policies.
      Therefore, end hosts must not be allowed to create "any" paths, only ones
      compliant with the policies of the ASes involved.
      In order to enforce this at line rate and without needing much state on
      the routers, SCION requires the HFs to contain verification
      information.
      For standard SCION, this information is a cryptographic MAC keyed by an
      AS-specific secret key.[fn:4]
      The AS distributes the HFs including this pre-computed MAC during path
      discovery, and therefore if a hop field in the end-host-created path
      contains a valid MAC, it is proof that the end host got this HF from the
      creator AS.
      The MAC for a HF is computed over itself and the HF occuring
      previously in the path (see figure [[fig:mac-chaining]]), so that the end host
      cannot arbitrarily join multiple valid path segments into a single path if
      it has not been explicitly allowed.
      The MAC verification is based on AES-CMAC TODO[cite the RFC], because with
      dedicated hardware, computing AES can be done very efficiently at line
      rate. TODO[would be great to have something to cite here -- look for what
      Adrian ended up citing when he asked me what to cite :D]
      Because the forwarding is otherwise rather simple, achieving a
      sufficiently fast HF verification routine will be one of the more
      interesting aspects of our implementation.

      #+NAME:   fig:mac-chaining
      #+CAPTION: TODO somebody should write something here.
      [[./img/mac-chaining.svg]]
      # TODO somebody should change the colours so that the whole HF is coloured,
      # and should copy the fixed version back to the presentation.
      # (and then should change this picture to render correctly with pdf_tex)
***** IP overlay
      In order to enable inter-operability with existing networks, SCION packets
      may use an IP/UDP overlay.
      The software border router currently requires this, as it uses a UDP
      socket to get SCION packets.
      Therefore, our implementation must accept SCION within IP, and must send
      out packets wrapped in the correct IP/UDP overlay, i.e. the next hop's IP
      address and UDP port.
      In the future, SCION will also run directly on top of L2 (when given a point
      point-to-point link).
      Our implementation should therefore either support both, or make it easy
      to add direct SCION over Ethernet links in the future.
***** Putting it all together: Border router behaviour
      TODO[not sure if this should be here or later on in the implementation: it
      makes sense to have it here, but what if someone isn't reading this
      section :D]

      In accordance with the above, our border router must do the following:
      1. Extract and parse the current HF according to the offset information
         in the offset header.
      2. Verify the ingress interface and the incoming IP overlay.
      3. Check that the HF is not expired.
      4. Validate the HF MAC.
      6. Update the HF offset information.
      5. Update the IP overlay header.
      7. Select the output port corresponding to the egress interface and send the packet out.
***** Related work
      The reference software router is available at TODO cite scionproto github.
      Since this runs in software and is not optimised for performance, it can
      achieve a few Gbps on normal hardware.

      We are aware of ongoing work by various groups: one creating a high-speed
      software implementation (several tens of Gbps), and two hardware-based
      implementations: one targeting an FPGA and programmed in Verilog, and one
      targetting a programmable switch (due to the limitations of the hardware,
      this one will support "SCION with caveats").
      At the time of writing, none of this work has been published.
*** DONE High-speed packet forwarding
    CLOSED: [2019-07-23 Tue 22:28]
    TODO this whole section could be replaced with a picture like this:
    #+begin_src text
      ^           : can do SCION to the right of this line
      | * ASIC    :
    p |      * programmable switch
    e |           :
    r |           :
    f |           :
    o |           :    * FPGAs
    r |           :
    m |           :
    a |           :
    n |           :
    c |           :        * eBPF
    e |           :         * DPDK
      |           :            * "normal" SW
      +-------------------------->
           flexibility
    #+end_src
    Should I just do that and have significantly less text?

    # This section is kinda terrible, because there are too many words in it,
    # but I'm afraid I don't have enough time to write less.

    There are multiple approaches that enable high-speed packet processing.

    On the software side, the main approaches are eBPF and DPDK.

    *eBPF* is an open-source in-kernel user-programmable virtual machine,
    originally introduced in BSD and later ported to GNU/Linux.
    It allows the user to implement their own packet processing rules without
    losing performance due to copying to userspace and back.
    The performance of eBPF on modern hardware is on the order of
    10 Gbps.

    *DPDK*, the Data Plane Development Kit, is a set of data plane libraries
    and network interface card (NIC) drivers that enables fast packet processing
    in userspace.
    It abstracts the hardware and software environment in order to enable
    target-independent implementations.
    Its performance on modern hardware is also on the order of 10 Gbps.

    To achieve higher efficiency and cost-effectiveness, using a hardware
    approach is often preferred.
    For mature protocols (i.e. ones that are very unlikely to change), it is
    preferred to build a custom ASIC, i.e. a chip with the exact circuitry
    required to perform the function.
    Examples of ASICs used in networking are Ethernet controllers (also on
    NICs in PCs) or IP prefix matching tables in dedicated router
    hardware.

    *ASICs* have very good performance characteristics and they are
    cost-effective at large quantities, but the one-time development costs of
    ASICs are extremely high and if the protocol changes, an ASIC cannot be
    reprogrammed.
    Therefore, for new protocols such as SCION, we need to look at
    programmable hardware.
    One flavour is programmable network switches: a fixed structure with some
    programmable elements.
    An OpenFlow switch is one example: the processing pipeline is fixed, but
    one can to an extent choose which fields are matched and what action is
    performed based on the match.
    Recently, more flexible programmable switches based on the P4 language
    (see [[*P4]]) have become available.
    These have a fixed architecture, i.e. the general "shape" of the
    processing pipeline: an example would be
    "parser → checksum verification → match-action pipeline →
    checksum calculation → deparser".
    The functionality within each of these blocks is programmable to an
    extent, but still limited by the capabilities of the underlying hardware.
    In exchange for these limitations, the hardware can be optimised and can
    achieve throughput up to several Tbps.

    Unfortunately, currently available programmable switches do not have all
    capabilities required for SCION: notably, the high-performance switches
    miss a cryptographic functions module, without which we cannot efficiently
    implement the AES-based HF MAC.
    Further, programmable switches do not provide much insight into the
    internals of the execution (and any such insight would anyway be limited
    to the specific switch), so with these, we would not be able to discover
    the bottlenecks and find opportunities for optimising the SCION protocol
    for hardware in general.

    A good tradeoff between flexibility and performance, which additionally
    shows more of the hardware design process, are *FPGAs*.
    Designing for an FPGA gives us the full power (and responsibility) of
    designing fully custom hardware: 
    we are not limited to whatever the manufacturer included, and
    if we need an AES module, we can add an AES module.
    The full programmability of the circuit comes at the cost of performance:
    assuming a good design, a single FPGA can handle on the order of 100 Gbps
    (which is about an order of magnitude above software, and about an order
    of magnitude below programmable switches and ASICs).

    When designing for an FPGA, we have visibility into the various parts of
    the system, and can see which parts are "difficult" to implement
    efficiently.
    Because the design process for FPGAs is the same as the first steps for
    creating an ASIC, it is reasonable to assume that things problematic on
    FPGAs would also be problematic on an ASIC.
    This allows us to make good guesses about the difficulties in hardware in
    general, and therefore propose generally useful changes to the SCION
    protocol.

    Due to hardware availability, the flexibility vs. performance tradeoff, as
    well as the insights that can be gained in the design process, we have
    chosen an FPGA for our work.
*** DONE NetFPGA
    CLOSED: [2019-07-29 Mon 10:29]
    The NetFPGA is a family of open-source hardware and software for prototyping
    of network devices.
    They are FPGA-based devices with several high-speed Ethernet ports.
    Being FPGA-based implies that these devices are fully programmable.
    Therefore, we will be able to include all the required functionality, such
    as parsing of SCION packets, AES-based MAC computation, timestamp
    validation, and communication with the control plane.

    Their newest (as of 2019) product, the NetFPGA SUME cite:sume, has 4 ports
    with 10G Ethernet, thus enabling a total throughput of 40 Gbps.
    It incorporates Xilinx's Virtex-7 690T FPGA, which is a high-end FPGA
    suitable for large projects.
    Due to this, and the availability of a P4 toolchain (see [[*P4]]) targeting
    the NetFPGA SUME, we have chosen to use this hardware for our project.
*** DONE P4
    CLOSED: [2019-08-01 Thu 12:02]
    P4 is a programming language for specifying packet processing pipelines.
    Building on previous software-defined networking efforts, it allows switches
    to be reprogrammed by the end user.
    It is target-independent, and therefore can in principle be used for
    programming anything from software switches to high-performance ASICs with
    minimal changes to the program.
    It is general enough to express the processing of almost any reasonable
    network protocol, including SCION, and high-level enough to spare us from
    target-dependent implementation details such as manually managing
    pipelining.

    For programming FPGAs, P4 enables a much more high-level approach compared
    to traditional hardware description languages (HDLs) such as VHDL or Verilog.
    While the traditional HDLs are more general and give the user far more
    control, P4's focus on a single purpose (packet processing) enables it to
    abstract away many common features of packet processing pipelines, and lets
    the programmer focus on the interesting features.
    Further, its choices about which features are not supported (such as
    unbounded loops or arbitrary array access) enable the P4 compiler to
    guarantee line rate processing ("if it compiles, it will run fast").
    Our initial examination of P4 suggests that it provides appropriate
    abstractions, and that the benefits of a faster development cycle,
    maintainability for software engineers, and target independence
    outweigh the loss of fine control for the use case of building a SCION
    router prototype.

    P4 is a relatively new language (the specification for P4_16, the version we
    use, was published in May 2017).
    Therefore, the first interesting question is P4's suitability for describing
    non-traditional network protocols such as SCION.
    Beyond those concerns, the toolchains for targeting specific hardware, and
    especially the NetFPGA, are at this point experimental and not well tested
    (as we will see in chapter [[*Implementation Challenges]]).
    Nevertheless, the abstractions offered by P4 may be worth it, especially
    because the "new, untested technology" problems will likely get less severe
    in the future, and therefore having a P4 implementation for SCION will become
    more and more useful over time.
*** TODO [0/4] Introduction to designing for FPGAs
    TODO is this a good name for this chapter?
    The design process for an FPGA is very different from software engineering.
    Though this is a difficult task, in this section we attempt to provide an
    overview of it from the perspective of a "converted" software engineer.
***** TODO [0/2] Concepts:
******* TODO FPGA area
******* TODO Timing constraints
***** TODO Overview of the process
***** TODO think in space, not time
      - everything happens at the same time
      - TODO didn't I start writing this down somewhere else? either tiddlywiki or website :D -- find it!
***** TODO resources / limiting factors
      - Area instead of # of instructions
      - Timing => path length + logic complexity
* [0/4] Aims
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
TODO maybe I don't even want to have this chapter, but just have the "Aims"
section in Introduction,
because (contrary to the SDN-CH presentation) I am not selling this as "I'm
going to enlighten you about P4" and then two of these things look less relevant
and I suppose it makes sense to say this in Introduction anyway and blah.
Hi reviewers, your opinions on this matter are especially welcome :D
#+begin_comment Ain't nobody got time for this
# *** TODO Deployable SCION BR
#     - forwarding at line rate => with NetFPGA, that is 40Gbps
#     - usable with real traffic
#     - integrated with existing SCION infra (control plane, monitoring/metrics)
# *** TODO SCION as a library
# *** TODO Guidelines for high-speed P4
#     or gaining experience or whatevs
#     Listen to my advice and you too can process packets at high speeds, even if you are not a hardware person.
# *** TODO Optimising the SCION protocol for HW
#+end_comment

* [2/2] Design overview
  The border router's algorithm, as outlined in section [[*Putting it all together:
  Border router behaviour]], is as follows (more details have been added here):

  1. Identify the packet as SCION and parse the SCION common header.\\
     If the packet is not SCION, send it to software.\\
     If the parsing fails, drop this and generate an SCMP[fn:5] error packet.
  2. Extract and parse the current HF according to the offset information in the offset header.\\
     If the extraction or parsing fails, drop this and generate an SCMP error packet.
  3. Verify the ingress interface and the incoming IP overlay.\\
     If incorrect, drop this and generate an SCMP error packet.
  4. Check that the HF is not expired.\\
     If incorrect, drop this and generate an SCMP error packet.
  5. Validate the HF MAC.\\
     If incorrect, drop this and generate an SCMP error packet.
  6. If the packet destination is in this AS, forward it according to the intra-AS routing.\\
     If the HF contains the =FWD_ONLY= flag, drop the packet instead and generate an SCMP error packet.[fn:6]
  7. Update the HF offset information.
  8. Update the IP overlay header according to an egress interface ⇒ IP overlay data table,
     including recomputing IP and UDP checksums.
  9. Select the output port corresponding to the egress interface and send the packet out.

  TODO if I weren't lazy, this could be a fancy flow diagram.
  Hi reviewers, should it be a fancy flow diagram? (Maybe additionally to this
  text, because it's a lot of text.)

  Note that the fast path is quite simple, but the error
  generation (which needs rate-limiting and may change significantly in the
  future) and local delivery (which needs additional configuration and state on
  the router for intra-AS routing) are more complicated.
  Therefore, a key design decision is to structure this project as a "really
  smart NIC": all packets which can be completely processed in the FPGA will be
  processed in the FPGA, and any packets which cannot be completely processed
  (for any reason) will be sent to the OS unmodified, through what looks like a
  normal network interface to the OS.
  The OS-visible interface will, further, pass through any packets sent to it by
  the OS, so that our implementation does not need to know anything about the
  unprocessable packets and any replies.
  This, together with SCION's stateless design, enables us to run the software
  SCION router unmodified and completely unaware of the fact that the FPGA
  taking care of most of the traffic.
  Thus the code running on the FPGA can be kept relatively simple, as it only
  needs to handle things that must happen at line rate:
  any SCION control plane messages, error handling, or any of the intra-AS L3
  packets such as ARP will transparently "just work".
  Additionally, with this approach, we can start with the very simple "pass
  everything through to the OS" program, and incrementally move more and more
  functionality into the FPGA, which greatly helps with development speed.

  #+NAME:   fig:design-overview
  #+CAPTION: TODO somebody should write something here.
  [[./img/design-overview.svg]]

  Figure [[fig:design-overview]] shows the components of our design.

  All the highlighted modules in the figure are loosely coupled in order to ease
  maintaining, extending, and building on top of this project.
  Thanks to the idea of transparently passing unprocessed packets to the OS, the
  processing pipeline can stay simple, and the control plane software can be
  just a thin wrapper running alongside the unmodified SCION router.
  Furthermore, if the control plane gets extended or changed, it is sufficient
  to upgrade the software router and none of this project's code needs to be
  changed, as long as there are no changes in the forwarding logic (which
  isn't likely to change as often).
* [0/5] Implementation Challenges
  The problems we encountered during the implementation were too numerous to
  list completely.
  Therefore, in this section, we present a select few particularly interesting,
  challenging, or instructive issues, and our solutions for them.
  # originally wanted to divide this into parser, validation, forwarding, etc... but
  # I don't think that makes much sense, as e.g. timing or stupid compiler were a
  # problem across the whole thing

  TODO order of sections?

*** INPR [2/4] Software engineering aspects
    TODO do I group this like this, or do I just promote the subsections here to separate sections?

    From the software engineering perspective, this project is somewhat on the
    larger side given the modest time and personnel assignment of a single
    Master thesis.
    Therefore, in order to speed up development, we needed to come up with a few clever ideas.
    This section introduces those.
***** DONE Project building workflow
      CLOSED: [2019-08-16 Fri 14:17]
      The standard workflow for building a project for FPGAs is very
      time-consuming, complicated, inconvenient, impossible to perform without
      training or lengthy documentation, and requires manual interaction in
      multiple steps.
      In the case of this project, it takes over 6 hours to go from source code
      to a binary that can be flashed onto the hardware.
      Originally, these 6 hours were interleaved with frequent manual checks
      that required opening the FPGA development environment GUI and running
      multiple long commands with input manually copied from previous steps.
      We do not consider that to be a sensible workflow, and if we had kept it
      that way, we would not be able to make progress fast enough to get
      anywhere with a project as complex as this.
      Therefore, one of the first things we worked on, before delving into the
      project-specific issues, was to improve the workflow.

      Due to this, as well as due to supporting multiple targets as described in
      [[*Target independence/portability]], a lot of thought went into organising
      the project's source code repository, and into scripting the build process.
      This required vastly more effort than anticipated, because the
      numerous NetFPGA scripts make unnecessary and often unsatisfiable
      assumptions about the project's structure.
      However, it was worth it:
      at the moment, the project can be built simply with ~make build~, which
      requires no manual interaction (nor lengthy documentation).
      This frees the programmer from frequently checking in on the build,
      allowing them to spend those 6 hours more productively.
      Further, running ~make~ in the project directory lists (automatically
      generated, and therefore always up-to-date) tasks and build settings that
      the programmer may need, thereby reducing the need for out-of-band and
      thus inevitably out-of-date workflow documentation.
***** TODO Modularity and incremental development
******* fake network interfaces over DMA
******* control plane
        twisted => trivially composable => trivial to add new features, mix&match
***** DONE Target independence/portability
      CLOSED: [2019-08-16 Fri 15:56]
      Writing portable bare-metal software is a non-trivial task with no general
      solutions, as every project faces different challenges in this area
      depending on the project's aims, and the number and diversity of the
      targeted platforms.
      In our case, P4 is in theory a target-independent language, and the same
      code can be compiled for many different targets, from software targets
      such as a user-space switch or a DPDK application, to hardware targets
      such as FPGAs and programmable switches.
      However, in practice, every target has different limitations, supports a
      different subset of the P4 language, and requires different extra
      resources (i.e. files needed to build the program for this target).

      For this project, we chose to support the open-source reference P4 software
      switch and the NetFPGA SUME board, and keep the door open for easily
      adding other targets in the future.
      In the ideal case, we would be able to work within the intersection of the
      P4 features supported by all the intended targets, and write unified code
      for the vast majority of the functionality.
      However, unfortunately (though not surprisingly), in the case of the NetFPGA's
      proof-of-concept toolchain, the limitations and unsupported P4 features
      turned out to be significant
      (see sections [[*Working around compiler/toolchain bugs]] and
      [[*Implementing the parser]]).
      Therefore, confining ourselves to the subset of P4 supported by both the
      reference compiler and the NetFPGA compiler would not allow us to
      implement SCION.
      As such, a single, unified codebase could not be achieved and we
      frequently needed to write different code for each target.
      
      In order to avoid a combinatorial explosion of different implementations,
      we chose to not depend on targets in our code, but on features.
      In other words, our code's ~#ifdef#~ statements (which conditionally enable
      or disable code) were not of the form ~#ifdef TARGET_NETFPGA#~, but e.g.
      ~#ifdef TARGET_SUPPORTS_VAR_LEN_PARSING~.
      This means that we will not necessarily need to modify existing code when
      we add a new target, we will just need to define the features it supports.
      We provide an easy way to check for features required by the project's
      code, so that adding a new platform requires as little effort as possible:
      running `make find-all-target-supports` prints all ~TARGET_SUPPORTS_*~
      features that the code uses.

      In order to accomodate for diverse build processes and supporting files,
      while avoiding duplication where possible, we have created a
      two-level structure in our repository that captures the various types of
      differences among targets that we anticipate.
      The supporting files, as well as Makefiles that define the build process,
      live under either ~platforms/PLATFORM~ if architecture-independent, or
      ~platforms/PLATFORM/ARCHITECTURE~ if architecture-specific.

      The differences between the software switch and the NetFPGA can be handled
      cleanly with our approach, which proves that it does indeed work in
      reality.
***** TODO Control plane
      While the focus of this project is on the data plane, we needed to create
      a minimal control plane, so that we could test the full functionality
      required of the data plane.
      The design of the control plane is also interesting from the modularity
      viewpoint.
      Therefore, this chapter presents a brief overview of 

      independent modules, often complementary to the P4 modules => something
        something modularity runs across the whole stack
        Perhaps also TODO have a look at my P4 presentation. Maybe there's
        something good in it :D // plagiarising myself
        Design decision: Using registers rather than digest packets so that I
        can do that transparent software router trick super easily.
********* What was horrible:
          existing Python control plane API sucked, so I rolled my own
          - tables: bugs in interpretation of the values
          - everything was hard-coded
          - only 32-bit registers supported, but that goes all the way to the C API and the bus
*** TODO [1/4] Implementing the parser
    TODO should this be a sub-section of [[*Working around compiler/toolchain bugs]]?
***** DONE Handling the variable-length SCION path
      CLOSED: [2019-08-05 Mon 11:51]
Unfortunately, the SDNet P4 compiler implements only a subset of P4, which has
created unexpected challenges when implementing the SCION packet parser.
The biggest issue was that at the time of writing, with P4-SDNet
the parser cannot work with any variable-length data: this includes not only
=varbit<n>= types, but also header unions, and -- most importantly -- header
stacks.
Furthermore, it is unable to even skip over variable-length parts of the packet.
Simply put, all packet offsets must be compile-time constants.
This poses a problem for SCION: the path in the packet is variable length (it
can contain any number of hops).[fn:varlen]
Therefore, the parser cannot easily deal with the path in the SCION
packet.[fn:cantparse]

To get around this problem, we employed the following steps:

First of all, we opted to design the parser so that it parses only the actually
needed data: while the path can be arbitrarily long, any single BR only needs to
process $O(1)$ hop fields (usually one, or two in case of a shortcut path).
This not only makes it possible to compile for the NetFPGA, but also improves
performance on other targets.

Next, we needed to solve the problem of emitting headers we have skipped:
using only the standard features
of P4, it is impossible to deparse parts of the header which have not been
parsed. (The payload is copied without being parsed, but the payload is defined
as anything *after* the last thing we parsed -- so if we skip parsing something
in the header, it is lost and we are unable to emit it on the output interface.)

The solution on the NetFPGA is to use the non-standard ~packet_mod~ feature of
P4-SDNet, as this (unlike the standard deparsers) allows to modify the existing
header instead of creating it anew, thereby allowing us to not lose the skipped
parts of the header.
The ~packet_mod~ feature mirrors the structure of the parser in the deparser: it
allows us to define a state machine that produces the output header by skipping
over or updating the input header as needed.

Using the ~packet_mod~ feature is not straightforward, either: we needed to
switch to the ~XilinxStreamSwitch~ architecture, as this feature is not
available in the ~SimpleSumeSwitch~ architecture that is the default on the
NetFPGA.
This required modifying the Verilog wrappers provided by the NetFPGA developers,
which was not trivial: the P4-SDNet compiler is closed-source and the few lines of
documentation in the wrappers were actively misleading.
Therefore, much trial and error was required to understand what was going on and
how to change it.

Obviously, using a non-standard SDNet-only feature means that with this
approach, the program would not compile on a standard P4 compiler.
However, standard P4 compilers (unlike the P4-SDNet compiler) tend to implement
parsing variable-length headers.
Therefore, we are able to emulate ~packet_mod~ for standard compilers by adding
an extra struct to keep track of the "skipped" parts of the headers, and instead
of skipping them, we parse them into the (variable-length) fields of this extra
struct.

We can use the C preprocessor to hide this difference, thereby keeping our
code portable while being able to use ~packet_mod~ where available.
This not only allows us to parse the variable-length SCION packet on the
currently incomplete P4-SDNet compiler, but also allows us to harness the
performance benefits of the ~packet_mod~ feature on any target where it is
available.

To make this approach work, the last step is to turn all packet offsets,
including the ones used only for skipping, into compile-time constants, so that
P4-SDNet is willing to compile the code.

Fortunately, SCION hop fields are always multiples of 8 bytes.
Therefore, the obvious approach is to add a parser loop that skips over 8-byte
chunks until it gets to the needed place.
Unfortunately, when attempting to compile this, the P4-SDNet compiler exhibited
a rather curious behaviour: due to what we assume to be an off by one error in
the compiler, the loop compiled into invalid SDNet code and was not accepted by
the later stages of the build process.
We attempted to isolate the problem to get a better understanding of it, but the
compiler bug manifested only in very specific conditions, and thus we were
unable to find a workaround for it.
Therefore, the loop approach did not work.

The final approach (which did work, though at a cost) was as follows:

If we assume a maximum path length $K$, there are
only $O(K)$ many options for how many different sizes we might need to skip.
Therefore, we can use the C preprocessor to "unroll" the parser and create
separate states for skipping $1, 2, ..., K-1$ hop fields.
This causes an $O(K)$ increase in FPGA area usage, but no latency increase --
our logic becomes wider, but not deeper.

Unfortunately, the FPGA area usage increase comes with an additional problem:
the amount of RAM needed to build the design increases with area, and for this
case, we were unable to build the parser for paths larger than 16 with 32GB of RAM.
While "get more RAM" would be a viable approach, it is not very elegant, and the
FPGA area usage is also a cost that is worth bringing down.
Therefore, we came up with a two stage skip idea to reduce these:
if we want to support a max path length $K$ blocks (let's say $K = 64$), we create two
skips: the first one will skip over "big" blocks of size $\sqrt{K}$ at a time, and
the second one will skip over normal-sized blocks.
This way, we can skip over any number of blocks $N, 0 \leq N < K$ by first
skipping over $\sqrt{K} * \left\lfloor \frac{N}{\sqrt{K}} \right\rfloor$ "big" blocks
and then skipping over $N \mod \sqrt{K}$ "normal-sized" blocks.
Instead of requiring $O(K)$ FPGA area (and therefore RAM), this requires only
$O(\sqrt{K})$ and thus enables much longer paths at reasonable costs.

[fn:varlen] The SCION host addresses are also variable-length, as the address
type tag in the common header defines what kind of address it is.
For this case, we opted to use the C preprocessor to conditionally replace the
union with a struct with three fixed-length fields (one for each possible type
of address), only one of which is parsed and made valid for a given packet.
(This causes a small increase in FPGA area usage, but any other solution would
be significantly more complex, so this is a good tradeoff.)

[fn:cantparse] In fact, it would be possible to parse the whole SCION packet by
using the C preprocessor to "unroll" the parser at compile time, and parse the
path segments into ~struct~'s with fields such as =hop1=, =hop2=, ... (size
fixed at compile time).
However, this would make actually using the fields very difficult, as I would
need more preprocessor magic to index into such a struct; and additionally it
would drastically increase my FPGA area usage.

***** TODO reject behaving contrary to even the NetFPGA devs' expectation
      can't link to issue because not public :-/
***** TODO timing
***** TODO the final design
      parser state machine diagram
*** TODO Hop field validation
    Before a SCION packet can be forwarded, we need to validate that this path
    (specifically, this hop) is allowed.
    There are two parts to that: we need to check that the hop field used in the
    path is not expired, and we need to check that it was in fact created (and
    thereby enabled) by our AS, not a malicious party by checking the HF MAC.
    Here we briefly discuss each of those steps.
***** MAC
      adding extern (pipelined! <-- took forever to find out)

      Specifically, SCION uses the AES-CMAC function as specified by RFC 4493.
      It needs to MAC at most 2 at most 256-bit blocks per packet, which
      translates to TODO AES-128-ECB computations per packet.

      I currently don't support long HFs or VRFY_ONLY, so I am doing
      single-block CMAC. For that, I need 1 AES for key derivation + 1 AES for
      the MAC computation. Currently I do the key derivation per packet, because
      it's easier to implement in P4, so I need 2 AES cores. But key derivation
      could happen when setting AS key, as there is just one, which would lead
      to needing only 1 AES core.
***** timestamp
      just write clock by control plane
*** TODO [1/5] Working around compiler/toolchain bugs
    Some hurdles are expected when working with cutting-edge technology.
    However, the state of the NetFPGA's P4 toolchain was enough of
    an issue to warrant a separate section in this thesis.
    Therefore, in this section we unfortunately present a subset of the problems
    encountered.

    Note that the parser-related problems (and their solutions, and the problems
    in the solutions) were interesting enough that we discuss them separately in
    [[*Implementing the parser]].
    We do not re-iterate those issues here, so see also that section for a
    complete picture.

    TODO reorder the sections
***** TODO the whole thing is stupidly complex
***** TODO extremely fragile, randomly stops working, and then requires on average 2-3 days to debug
      had a working implementation where I could measure throughput 2 months
      ago, now I can't make the same thing work
***** DONE Table matching broken under unclear circumstances
      CLOSED: [2019-08-19 Mon 15:42]
      We use a table to match the SCION interface ID with the physical port and
      the IP overlay settings.
      We had tested table matching previously in a toy project when getting to
      know the toolchain, so we did not expect any problems with it.
      However, during the development, table matching suddenly stopped working.
      We triple-checked that the keys in the table and in the packet data were
      correct, but that was not the problem.
      As a sanity check, we went back to the known working toy project, and made
      sure that tables still worked there, which they did.
      Having no indication of what was wrong, we proceeded to copy over parts of
      our code between the two projects in order to narrow down the possibilities.
      It was largely by accident that we discovered that if we include an extra
      dummy table at the beginning of the program, the actually relevant table
      would magically start working again.
      In the end we discovered that only the "first" table match was broken:
      if we included two tables, the one that was accessed first in the control
      flow of the program would fail to match, and the second one would work.

      We reported this problem to the NetFPGA developers, and worked with them
      to find out what was going on and why this was only happening in our
      project.

      Finally, we found out what was going on:
      it turns out that calling an extern function (i.e.~escaping from P4 into
      a Verilog/VHDL module) corrupts some state in the P4 module and breaks the
      following table.
      Our guess is that the use of the table then restores the corrupted state,
      and after that the execution proceeds as expected.
      This behaviour is rather concerning, as the P4 module should in theory be
      completely independent from other modules, and not even the NetFPGA
      developers know why this is happening.

      In our case we need to call extern functions in order to validate the HF:
      as described in section [[*Hop field validation]], we need an extern function
      to get the current time (needed to validate the timestamp) and to compute
      AES-128 (in order to check the HF MAC).
      As we want to send the unmodified packet to the SW if any errors are
      encountered, these checks should happen as soon as possible.
      Specifically, we would like to do them before the use of the table, as
      using the table modifies the packet (in P4, the "match-action", i.e.
      looking up a key in a table and performing an associated action based on
      the match, is an atomic operation).
      Therefore, our first idea was to add the dummy table, so that we could
      keep the control flow of "first call externs, then fix the corruption
      using the dummy table, then access the actually relevant table".

      However, the extra table costs about 0.1 ns of time, which is a
      non-negligible amount (see section [[*Meeting timing constraints]] for a detailed
      discussion).
      Thus, when optimising timing, we switched to a different approach:
      because we are using the ~packet_mod~ deparser described in [[*Implementing
      the parser]], we are able to choose very late in the program (specifically,
      in the deparser) to either commit to the packet modifications or keep the
      old data.
      As such, we are able to use the following approach:
      First, we access the table (which may modify the in-program representation
      of the packet, but does not affect the result of the checks).
      Then we call the externs and depending on the results of the checks, we
      may or may not set a "can modify" flag.
      We then check this flag in the deparser before committing to the
      in-program packet modifications in the real packet on the wire.
      This way we are able to use tables together with externs without using the
      somewhat expensive dummy table workaround.
***** TODO had to write my own reg_write and stuff
***** TODO HW is silly
      and we can't debug it
******* sometimes DMA may need an extra reboot?
*** TODO Meeting timing constraints
    The various costly workarounds as explained in the previous sections of this
    chapter, together with some questionable design choices in the P4-NetFPGA
    base design[fn:7], take up almost all of the FPGA area.[fn:8]
    Due to this, the place and route step of the design process has difficulty
    satisfying timing constraints.

    Even after more than a month of optimisation, the full design has a negative
    slack of about 0.08ns: running on a 200MHz clock requires all paths to take no
    longer than 5.0ns, and in the full design the longest path requires 5.08ns.
    At this point, the FPGA is too full for any optimisations to help: all of our
    attempts just shifted the problem from one place to another, but did not solve
    it.
    Nevertheless, during the optimisation process, we have learned a great deal:
       - TODO example of data dependency graph and how I optimised it

***** TODO Tables
      squishing => but then large table => helps with timing but fills the FPGA

* [0/4] Results

  What am I supposed to put here?
  Ideally: here are the pictures about how effing fast it is. Also about timing
  and utilisation and perhaps power consumption.
  # > What happened (objectively)?
  # > Do not interpret, simply state the facts.
  # > Let's be honest: the first thing most of us do when skimming a paper is look
  # at the figures. If your key results can be presented in figures, then start
  # with that, and structure your paper around that.

  Due to inadequacies in the P4-NetFPGA toolchain as explained in
  [[*Implementation Challenges]] and especially in [[*Meeting timing constraints]], we
  have not been able to test the full system.
  Therefore, we do not present results for the full design: instead, we show the
  data for the various components of the design, and we draw conclusions based
  on these and our knowledge of how composing systems in FPGAs affects
  performance.
*** TODO Throughput
    pretty much my magic dashboard
    (include queue sizes)
*** TODO Latency
    if I can
*** TODO Fraction of real traffic sent to CPU
*** TODO Resource usage
    ideally also per-component
***** TODO FPGA area
***** TODO Power consumption
* [0/4] Discussion
  # > Results are objective, but science isn't about listing data, it's about
  #   extracting meaning from what we observe.
*** TODO Why do we see the results we see?
    TODO what do we see? :D
    Because this is "SCION as a library", I should talk not just about the BR's
    performance, but also about the characteristics of the parts on their own.
*** TODO Guidelines for high-speed packet processing
    see TODO something in [[*Background and Related Work]] for general intro to FPGAs
***** what's easy and what's hard from the "what you want to do" viewpoint
***** insights about P4 => HDL translation
******* Timing
        - inout parameters correspond to long paths => timing problems
        - CAM tables are kinda expensive (~0.1ns)
        - TODO how to find the critical path?
        - example of data dependency graph and optimising it
*** TODO Implications for the SCION protocol
    TODO this is a bit complicated... I am providing suggestions, but the actual
    things that will make it to the next version of SCION aren't my work, they are
    someone else's work that takes into account my suggestions. How do I put that
    here?
***** TODO What SCION does right
******* Avoiding lookup tables
        show area of a CAM table
        and if I have too much free time, do a power consumption measurement
***** TODO What should be improved
******* TODO Defining maximum sizes
        Currently, the maximum path length in the packet header is unreasonably
        large (the 8-bit offset fields allow for up to 256*8 = 2kB offset), and
        the hop field length is virtually unlimited (the continue flag signals
        whether we need to keep reading, and there is no maximum length defined).
        In hardware, in order to enable pipelining, we need to create buffers of
        the "worst case" size.
        This consumes FPGA area (thereby increasing costs and possibly energy
        consumption) and, due to processing in fixed-size blocks, increases
        latency.
        Therefore, these should be limited. We propose the following:
        - limiting the maximum number of hops to some "reasonable" value, such as 64
        - limiting the maximum hop field size to e.g. 16 bytes
******* TODO Avoiding variable lengths
        - good: pad to a nice number (currently 8, in the future SCION will pad to 4)
        - ATM HFs can be any multiple of 8 bytes, in the future (thanks to the
          change to 4 bytes) SCION will have only 12-byte HFs
******* TODO Avoiding implicit lengths
        addr type
******* TODO Consider re-thinking MAC chaning for peering paths
        In the case of peering paths, bla TODO bla
# *** TODO what else have we learned?
* [4/6] Future work
  TODO it may or may not be a good idea to re-order these
*** DONE Completing the feature set / Adjusting for newer SCION versions
    CLOSED: [2019-07-24 Wed 14:28]
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    Due to difficulties with the NetFPGA's P4 toolchain, we currently do not
    implement everything in the current version of SCION, which means that a
    larger than necessary fraction of traffic must be handled by the CPU.
    Therefore, an obvious avenue for improvement would be to implement the
    missing parts of SCION, namely handling UP segments, shortcuts and peering
    paths.
    However, the handling of shortcuts and peering links may be simplified in
    the next version of the protocol, which will require modifications to this
    project's code anyway.
    Therefore, it is better to first accomodate the new protocol version (once
    it is finalised), and add support for all link types afterwards.

    Further, the current version of the project only supports overlays using
    IPv4, because unlike in IPv4, IPv6 checksums are computed over the whole
    packet, not just the headers.
    The P4-NetFPGA toolchain currently does not provide any way to compute with
    the packet body, so IPv6 checksums would require an unreasonable amount of
    effort to implement.
    The P4 code does contain support for IPv6 overlays and the checksum is the
    only missing piece.
    Therefore, enabling IPv6 overlays will be an easy improvement if the
    checksum becomes available (e.g. by targetting hardware with a different
    toolchain).
*** TODO [2/2] Researching the resource consumption
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    TODO umm the two things below are perhaps a bit too related to be two things :D
***** DONE Relative costs of crypto vs. routing tables
      CLOSED: [2019-08-13 Tue 17:33]
      A core part of the design of SCION is the assumption that per-packet
      cryptography is cheaper than state on routers (e.g. in the form of routing
      tables), especially as the Internet continues to scale up.
      While this is very likely true for configuration and therefore also
      personnel costs, it is less obvious for hardware manufacuring costs, as
      well as energy consumption.
      The initial results of this project indicate that performing the AES
      operations may mildly increase in-device packet processing latency (by the
      order of nanoseconds, which is negligible), but is cheaper in terms of
      FPGA area and thereby also energy requirements.
      However, due to issues with the NetFPGA toolchain, we have not been able
      to look into the details.
      It would be of great interest to find concrete numbers and show the exact
      improvements that can be obtained by using SCION's approach.
      More precise knowledge of the tradeoffs would also be useful in further
      optimisation of the SCION protocol.
***** DONE Energy requirements optimisation
      CLOSED: [2019-07-24 Wed 16:12]
      :PROPERTIES:
      :UNNUMBERED: t
      :END:
      In theory, not requiring large tables decreases the chip area and therefore
      its power consumption.
      However, the added cryptographic verification of every packet is a complex
      operation that may increase it.
      It has been theoretically predicted TODO citation that SCION may be able to
      use overall less energy per packet, but measuring it and seeing it in
      practice would be much more tangible.
      Moreover, with a hardware design, we may be able to look for opportunities
      for further energy requirements optimisation.
      Costs of running network equipment are nowadays largely due to electricity,
      plus there are environmental concerns to consider, and therefore an
      exploration of SCION's power requirements would be very valuable.
*** INPR Higher throughput
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    With the NetFPGA as our hardware target, we are limited to 40 Gbps by its 4
    10G ports.
    If not for that limitation, our design could achieve up to 51
    Gbps without any change (it processes 256 bits per cycle at 200MHz clock ⇒
    256*200e6 = 51e9).
    If not for the numerous costly workarounds, our design could run at a higher
    frequency, and with greater paralellism.
    Therefore, with a better toolchain, we may be able to achieve several
    hundred Gbps with a single FPGA of similar parameters as what we are using
    now.

    A SCION border router does not require any state other than static
    configuration, so the packet processing can be easily parallelised using
    multiple FPGAs.
    The only thing that needs to scale vertically is the switching itself, which
    can be done with speeds of several hundred Gbps with relatively affordable
    hardware (as long as we don't require the hardware to be programmable).
    Therefore, using several higher-throughput FPGA-enabled NICs for
    the packet verification and update, plus a non-programmable MPLS or IP
    switch for the switching (i.e. to handle buffering/queueing at high speeds),
    we could in principle scale to very high rates even without creating an ASIC.

    TODO The previous paragraph should actually go somewhere into [[*Discussion]]
    and just be referenced here.
*** DONE Running in production
    CLOSED: [2019-08-01 Thu 13:01]
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    Due to the problems explained in [[*Implementation Challenges]], and especially
    in [[*Meeting timing constraints]], we have not been able to deploy our router
    to routinely handle real traffic.
    Solving those problems, or porting our implementation to a target with a
    less broken toolchain, would let us do that, and therefore be the ultimate
    test for our implementation, as well as enable us to reap the benefits of
    the high-speed router in production.
*** DONE Adding COLIBRI and EPIC
    CLOSED: [2019-07-24 Wed 16:11]
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    While "plain SCION" is already a significant improvement over today's
    Internet, features built on top of it could provide even more benefits.
    Examples of such systems are COLIBRI, a system for bandwidth reservation
    that guarantees bandwidth even in the face of network overload and DDoS
    attacks, and EPIC, a source authentication mechanism that can run at line
    rate.

    It would be interesting to see how it would go to implement these more
    complex schemes in hardware, and whether line rate can still be achieved
    without unreasonable costs.
*** DONE Other targets, other high-speed SCION applications
    CLOSED: [2019-08-15 Thu 21:34]
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    Due to keeping portability in mind during the development, we anticipate
    that porting our border router to other targets should not be too difficult.
    Having a single SCION implementation usable in multiple scenarios could be
    very useful in the future.
    Some targets of interest are for example future FPGA-based NICs,
    programmable switches, or the P4 to DPDK compiler.
    Especially the last one would be a useful direction to go in, as DPDK runs
    on standard PCs, and therefore porting for the P4 to DPDK compiler would
    give us a high-speed switch that does not require special hardware.

    Thanks to the emphasis on modularity, our "SCION as a library" code could
    also be used in many applications different from the border router.
    Examples include a SCION-enabled network monitoring system / in-band network
    telemetry (parse SCION packets, collect metrics, and pass packets through),
    or a special-purpose end host with a P4-capable smart NIC, which could, by
    offloading SCION to the NIC, transfer data at otherwise unattainable speeds
    (both in terms of throughput and latency).
    Apart from the end results themselves, working on these applications would
    also help us improve the code base by challenging our assumptions about
    modularity and generality.
* [0/1] Conclusion
  # Bring it back to the big picture. How do your results fit into the current body of knowledge?
  # Most importantly, how can these results help you ask better questions?
  - high-security Internet protocols, and especially SCION, can feasibly be forwarded at high speeds
  - we see no major obstacles for implementing a very high throughput thingy
    (order of Tbps), and the minor things are going to be cleared up with the
    data plane redesign that incorporates my suggestions
  - P4 is an adequate language and though not everything is perfect, it is a
    useful tool that indeed helps achieve a quicker development cycle
  - we are looking forward to having more mature HW targets and toolchains, and
    we think there is much promise in continuing this work with those


#+LATEX: \bibliographystyle{abbrv}
bibliography:bibliography.bib

#+LATEX: \appendix

* Footnotes

[fn:8] For context, the Virtex 7 FPGA present in the NetFPGA is often used for
prototyping CPUs. To fill it up is a rather unexpected feat.

[fn:7] The P4-NetFPGA design includes a full Microblaze microprocessor in the FPGA.
This alone takes up about 30% of the FPGA area.

[fn:6] The =FWD_ONLY= flag can be used by the AS to indicate that this HF is
only usable for forwarding to other ASes, not for local packet delivery.

[fn:5] SCION Control Message Protocol: the equivalent of ICMP in SCION.
These packets should be rate-limited, and in future versions of SCION, they may
become source-authenticated (i.e. require additional crypto).

[fn:4] In addition to "standard SCION", SCION also supports packets with
end-to-end bandwidth reservations, and source-authenticated packets. For these,
the verification information is different. In this work, we only implement the
"standard SCION" mode, and will mention the other modes only very briefly.

[fn:3] Autonomous System: a network or collection of networks that managed and
supervised by a single entity or organization. An ISP's network is an example of
an AS.

[fn:2] Application-specific integrated circuit: an integrated circuit customized
for a particular use. Since ASICs are custom-built, they can be highly
cost-effective and energy-efficient, assuming a sufficiently large deployment.

[fn:1] Field-programmable gate array: a chip with many programmable logic blocks
and programmable interconnects that can be used for hardware prototyping.

* [1/3] Glossary
  meep, do I really need this? and if yes, where do I put it? TODO
*** TODO FPGA
*** TODO NIC
*** DONE target
    CLOSED: [2019-08-16 Fri 15:45]
    A hardware or software platform on which to run a program, for example a
    software switch or an FPGA.
    In the context of P4, a target is a platform and /switch architecture/ pair,
    as the same platform may support more than one architecture: for example,
    the NetFPGA SUME platform supports the =SimpleSumeSwitch= and
    =XilinxStreamSwitch= architectures.
    
# Local Variables:
# org-confirm-babel-evaluate: (lambda (lang body) (not (string= lang "emacs-lisp")))
# after-save-hook: org-latex-export-to-latex
# End:
