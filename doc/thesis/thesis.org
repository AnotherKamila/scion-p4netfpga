#+TITLE:  Line-rate packet forwarding for the SCION future Internet architecture
#+AUTHOR: Kamila Součková
#+DATE:   August 19, 2019
#+DESCRIPTION: Master Thesis
#+INCLUDE: thesis-setup.org

#+LATEX: \frontmatter
* [1/1] Abstract
  CLOSED: [2019-07-15 Mon 15:45]
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
  The SCION future Internet architecture is designed to provide route control,
  failure isolation, and explicit trust information for end-to-end communication.
  Its viability has already been demonstrated in production, but to work
  at Internet scale, it is necessary to make it perform at high speeds, reduce
  costs, and evaluate suitability for eventual implementation in hardware.
  This project implements a SCION border router capable of line-rate packet
  forwarding, currently running on an FPGA target.
  It uses P4: a new language for programming packet forwarding planes.
  This enables target independence, a quicker development cycle, and a more
  modular approach.
  Based on this work, we suggest changes to the SCION data plane that allow for
  more efficient processing in hardware.
* [0/1] Acknowledgements
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
  TODO write something

#+TOC: headlines 2
#+LATEX: \mainmatter
* [3/3] Introduction
  # [In field X, we still don’t understand Y & Z.]
  # Write a summary of the question(s) you are trying to answer.
  # What is the state of the world before your research came along?
  # Also, answer the harsh but important question: Who cares?
  # In writing this, you can start general, but make sure you clearly define the “before” state of the world’s knowledge for the specific area this paper is addressing.
*** DONE Why SCION?
    CLOSED: [2019-07-16 Tue 15:25]
    Today's Internet, based on IP and BGP, was conceived in a very different
    environment, with very different requirements and very different
    assumptions. Meant to be a research network, it assumed that
    access was not widespread (as only large institutions could afford a
    connection), that all entities connected to it trusted each other (and had
    out-of-band means to deal with misbehaviour),
    and that it would not grow large enough for outages to become difficult to
    manage.
    Considering these facts, it has scaled surprisingly well, but nowadays we
    are living in a very different world.

    Today, everyone is connected and everyone has their data on the Internet.
    With the huge number of connected entities, many of which have conflicting
    interests, trust can no longer be global and implicit.
    Users want control over their data, ISPs want control over their services,
    and states want to protect their infrastructure from outside actors.
    At this scale, convergence after path failure takes too long, and
    large-scale outages due to BGP route leaks are happening almost weekly.
    Furthermore, attacks on the Internet infrastructure, e.g. DDoS attack or BGP
    route hijacks, are becoming more and more common.
    In today's world, these issues can no longer be tolerated.

    In the future, the Internet will become even more critical. Automation (such
    as drones, self-driving cars, or remotely operated robots) will depend on
    the availability and security of the Internet.
    As more and more data moves online, trust will become even more of an issue.
    We will need ways to satisfy new requirements such as geofencing, which
    cannot be adequately fulfilled with the current Internet architecture.
    And as malicious actors get more and more sophisticated and powerful, their
    attacks will get even harder to stop.
    Therefore, we will need to move to an Internet architecture that is
    resilient to both unintentional failures and malicious attacks,
    can provide explicit trust information to the end users,
    and gives the end users as well as institutions control over whom they trust
    and what happens with their data.

    There have been may attempts to fix the IP+BGP-based Internet TODO[cite
    something], but patching an architecture designed with entirely different
    assumptions simply cannot solve all the problems TODO[cite something].
    Additionally, the IP-based approach also has scalability issues due to
    requiring very large routing tables, and this is bound to get worse in the
    future.
    Therefore, the SCION project chooses to build a clean-slate Internet
    architecture, with the goals of scalability, route control, failure
    isolation, and explicit trust information in the design.
*** DONE SCION right now
    CLOSED: [2019-07-16 Tue 17:16]
    Thanks to a well-thought-out design, as well as "real-life" considerations
    such as deployment, transition strategy, and engagement with industry, SCION
    is currently running in production in several locations TODO[cite].
    Additionally, a planet-wide research network for testing SCION is running
    thanks to SCIONLab TODO[cite SCIONLab paper].
    These use cases have proven that SCION is in fact suitable for real-world
    usage.
    In the near future, several ISPs are likely to start offering SCION
    connections to their customers.
    Therefore, considerations like throughput, cost-effectiveness, and energy
    efficiency are of great interest to many in the SCION community.

    The existing implementations of the SCION infrastructure, in particular the
    routers, run as applications on standard servers.
    This has enabled rapid development, as well as flexibility, and it will
    continue to be the primary approach until the protocol stabilises.
    However, with the current technologies, a software-based approach cannot
    achieve throughput above several tens of gigabits per second.
    Therefore, large-scale deployments would require many such routers, which is
    not cost-effective.
    From the research perspective, whether SCION can even in principle run at
    line rate, and what hurdles must be overcome, are still open questions.

    Especially thanks to the real-world deployments, SCION is now
    mature enough to lend itself to implementing in hardware.
    Though the current version of the protocol is very unlikely to be the final
    one, it would be useful to get an initial hardware-based implementation,
    mainly in order to evaluate the protocol's suitability for hardware.
    A successful hardware-based implementation would also be a good answer to
    the "can it run at line rate?" question, which would further increase the
    probability of deployment with commercial ISPs.
*** DONE Aims of this project
    CLOSED: [2019-07-18 Thu 13:37]
    TODO is this better inline like this, or in an item list?

    The first aim of this project is *implementing a border router capable of
    forwarding SCION packets at line rate*.
    We will target a NetFPGA SUME board, which will (in the ideal case) allow us
    to forward up to 40Gbps.
    The border router is the crucial building block of the SCION data plane.
    Therefore, having a high-speed prototype will open the doors to large-scale
    data transfers, as well as prove that infrastructure providers (such as
    ISPs) will be able to scale to meet the needs of many customers without
    incurring very high costs.

    Additionally, we wish to keep the work target-independent (as much as
    possible), and thereby create a "library for line-rate SCION" for a variety
    of targets and use-cases.

    An implementation targeting an FPGA[fn:1] is a good first step for
    evaluating the feasibility of building "SCION on chip": much of the design
    process is the same with FPGAs as with ASICs[fn:2].
    Therefore, the second aim of this work is to
    *confront SCION with hardware design expertise, and consider the possibility
    of building faster, more efficient designs in the future*.
    The knowledge gained in the process of implementation on the NetFPGA will
    allow us to better understand the requirements of running SCION in custom
    hardware, and predict whether a very high-speed and energy-efficient ASIC
    implementation could be built.
    As being able to run in hardware is a hard requirement for the success of
    any network-layer Internet protocol, knowing more about this question is
    crucial to the development and deployment of SCION.

    With the knowledge gained during the implementation, we will be able to
    fulfill the third aim of this project: *providing suggestions for the SCION
    protocol that would result in more efficient hardware implementations*.
    Running in hardware has been a consideration in the design of SCION from the
    beginning, but an actual implementation, rather than abstract reasoning, is
    likely to uncover opportunities for further improvement.
    Doing this early, before SCION has become widely deployed, allows us to
    implement any changes needed without having to worry about
    backwards-compatibility and enter the "real-life deployment" sphere with an
    already optimised protocol.
* [0/4] Background and Related Work
  In order to achieve this project's aims, we need to work in the intersection of
  several fields: among others network security, network protocols, software
  engineering, and hardware design.
  This chapter introduces what concerns us in each of the relevant areas, and the
  following chapters build on this information.
*** TODO [3/5] SCION data plane
    SCION is a clean-slate Internet architecture designed for
    route control,
    failure isolation, and
    explicit trust information
    for end-to-end communication.
    For a comprehensive presentation of the SCION architecture, see TODO cite the
    SCION book.
    In this section, I will introduce the aspects of the SCION data plane relevant
    for this work.
#+begin_comment Ain't nobody got time for this stuff
# The name SCION stands for "scalability, control, and isolation on
# next-generation networks", which summarises the aims of SCION: we will discuss
# below how these aims are achieved. First, let us have a look at how SCION works.
# ***** Overview of the SCION architecture
# ******* Isolation Domains
# At the core of SCION is the concept of *isolation domains* (ISDs): an ISD is
# an autonomous collection of ASes[fn:3] that manages its own routing
# infrastructure and root of trust (both for routing and PKI).
# Actors outside of the ISD are unable to influence either routing or trust within
# the ISD.
# The exact mapping of ISDs to physical world entities is a topic for further
# research, but for simplicity, we can imagine for the sake of this explanation
# that an ISD could map to a country or union of countries that share common
# jurisdiction and agreements.
# Multiple ASes within the ISDs run the *ISD core*, which is responsible for
# providing core routing infrastructure, as well as the PKI.
# These could be e.g. government-operated or large commercial ISPs.
# Non-core ASes then provide connectivity to end users, while relying on the
# services provided by the ISD core.
# The ISD is a self-contained entity, with everything needed for inter-ISD routing
# contained within the ISD.
# Therefore, the ISD is isolated from misconfiguration or misbehaviour by outside
# entites, which makes the network more stable and reliable.
# Furthermore, creating the hierarchy of separate ISDs instead of one global
# network helps with scalability, as described in TODO somewhere below.
# #+CAPTION: Multiple isolation domains (ISDs). Communication within each ISD is entirely handled within the ISD, and communication among different ISDs is facilitated by the ISD core. Note that while control plane communication always flows only among core ASes, inter-ISD data transfer is possible also over non-core links.
# #+NAME:   fig:isds
# [[./img/isds.png]]
# ******* Path discovery
# ******* Path selection
# ******* Packet forwarding
# The data plane blablabla.
#+end_comment
***** DONE Packet-carried forwarding state
      CLOSED: [2019-07-22 Mon 17:20]
      In order to scale without the need for state on routers (specifically large
      routing tables), SCION puts all information needed for packet forwarding into
      the packet header.
      In particular, the user-selected path that the packet needs to take through the
      network is present in the header, as a stack of /hop fields/ (HFs).
      This means that the packet headers are variable-size and can be somewhat large
      -- this is the tradeoff SCION makes to avoid large and potentially inconsistent
      routing tables in routers.

      Each HF in the path corresponds to an AS-level hop.
      It encodes the ingress and egress interface in its AS,
      verification information used by the AS to check that the end host is
      allowed to use this hop,
      the expiration time for this HF,
      and some additional information.
      The exact HF format is described in TODO[ref SCION book].
      In order to forward the packet, the router only needs to look at the
      "current" HF, i.e. the one meant for this AS.
      Therefore, the SCION header contains a pointer to the current HF.
      This is initially set to the first one in the path, and every egress
      border router increments it after processing it, so that a router can find
      its HF without parsing the whole path.
***** DONE Hop field verification
      CLOSED: [2019-07-22 Mon 17:20]
      Allowing the end host to assemble the path is great for giving the end
      host control, but for various reasons ASes may need to enforce routing
      policies.
      Therefore, end hosts must not be allowed to create "any" paths, only ones
      compliant with the policies of the ASes involved.
      In order to enforce this at line rate and without needing much state on
      the routers, SCION requires the HFs to contain verification
      information.
      For standard SCION, this information is a cryptographic MAC keyed by an
      AS-specific secret key.[fn:4]
      The AS distributes the HFs including this pre-computed MAC during path
      discovery, and therefore if a hop field in the end-host-created path
      contains a valid MAC, it is proof that the end host got this HF from the
      creator AS.
      The MAC for a HF is computed over itself and the HF occuring
      previously in the path (see figure [[fig:mac-chaining]]), so that the end host
      cannot arbitrarily join multiple valid path segments into a single path if
      it has not been explicitly allowed.
      The MAC verification is based on AES-CMAC TODO[cite the RFC], because with
      dedicated hardware, computing AES can be done very efficiently at line
      rate. TODO[would be great to have something to cite here -- look for what
      Adrian ended up citing when he asked me what to cite :D]
      Because the forwarding is otherwise rather simple, achieving a
      sufficiently fast HF verification routine will be one of the more
      interesting aspects of our implementation.

      #+NAME:   fig:mac-chaining
      #+CAPTION: TODO somebody should write something here.
      [[./img/mac-chaining.svg]]
      # TODO somebody should make the outline of the HFs wider and should probably
      # hardlink or what these images instead of copying from the presentation? But
      # that's terrible. But copying them and fixing one and not the other is also
      # terrible. Everything is terrible.
***** TODO IP overlay
***** DONE Putting it all together: Border router behaviour
      CLOSED: [2019-07-22 Mon 17:20]
      TODO[not sure if this should be here or later on in the implementation: it
      makes sense to have it here, but what if someone isn't reading this
      section :D]

      In accordance with the above, our border router must do the following:
      1. Extract and parse the current HF according to the offset information
         in the offset header.
      2. Verify the ingress interface and the incoming IP overlay.
      3. Check that the HF is not expired.
      4. Validate the HF MAC.
      6. Update the HF offset information.
      5. Update the IP overlay header.
      7. Select the output port corresponding to the egress interface and send the packet out.
***** TODO Related work
      TODO[Is there anything published about (one of) the SW BR or something?]
*** TODO High-speed packet forwarding
***** Intro to FPGAs for software people
******* think in space, not time
        - everything happens at the same time
        - TODO didn't I start writing this down somewhere else? either tiddlywiki or website :D -- find it!
******* resources / limiting factors
        - Area instead of # of instructions
        - Timing => path length + logic complexity
******* [0/2] Concepts:
        TODO but but but this should go way earlier because I'm referring to these all the time
        I suppose they should go to [[*Background and Related Work]]?
********* TODO FPGA area
********* TODO Timing constraints

***** existing approaches
software: EBPF, DPDK
programmable hardware: FPGAs, Barefoot Tofino-style things
why did we pick what we picked?
*** TODO P4
    this is a tool for solving above => relate this to that
*** TODO NetFPGA
    this is a tool for solving above => relate this to that
* [0/4] Aims
TODO maybe I don't even want to have this chapter, but just have the "Aims"
section in Introduction,
because (contrary to the SDN-CH presentation) I am not selling this as "I'm
going to enlighten you about P4" and then two of these things look less relevant
and I suppose it makes sense to say this in Introduction anyway and blah.
Hi reviewers, your opinions on this matter are especially welcome :D
*** TODO Deployable SCION BR
    - forwarding at line rate => with NetFPGA, that is 40Gbps
    - usable with real traffic
    - integrated with existing SCION infra (control plane, monitoring/metrics)
*** TODO SCION as a library
*** TODO Guidelines for high-speed P4
    or gaining experience or whatevs
    Listen to my advice and you too can process packets at high speeds, even if you are not a hardware person.
*** TODO Optimising the SCION protocol for HW
* [0/1] Design overview
The border router's algorithm, as outlined in section [[*Putting it all together:
Border router behaviour]], is as follows (more details have been added here):

      1. Identify the packet as SCION and parse the SCION common header.\\
         If the packet is not SCION, send it to software.\\
         If the parsing fails, drop this and generate an SCMP[fn:5] error packet.
      2. Extract and parse the current HF according to the offset information in the offset header.\\
         If the extraction or parsing fails, drop this and generate an SCMP error packet.
      3. Verify the ingress interface and the incoming IP overlay.\\
         If incorrect, drop this and generate an SCMP error packet.
      4. Check that the HF is not expired.\\
         If incorrect, drop this and generate an SCMP error packet.
      5. Validate the HF MAC.\\
         If incorrect, drop this and generate an SCMP error packet.
      6. Update the HF offset information.
      7. Update the IP overlay header according to an egress interface ⇒ IP overlay data table,
         including recomputing IP and UDP checksums
      9. Select the output port corresponding to the egress interface and send the packet out.

  TODO diagram of the components:
  show pic with data plane + normal SCION SW router + my thin control plane

  this is awesome because:
  - modularity: blablabla
  - simplicity: everything that doesn't have to happen at line rate, such as error packet generation, all control plane packet processing, even ARP and stuff, is handled transparently without any work on my side
  - "upgradeability": if the control plane gets extended / changed, I don't care, as long as the forwarding path format (which isn't as likely to change) is the same
  - enables incremental development of the HW design: start with just passing through everything, then add more and more features that don't have to go to CPU
* [0/7] Implementation Challenges
  # originally wanted to divide this into parser, validation, forwarding, etc... but
  # I don't think that makes much sense, as e.g. timing or stupid compiler were a
  # problem across the whole thing
*** TODO Target independence
*** TODO Incremental development
***** fake network interfaces over DMA
***** control plane
      twisted => trivially composable => trivial to add new features, mix&match
*** TODO Control plane
    independent modules, often complementary to the P4 modules => something something modularity runs across the whole stack
      Perhaps also TODO have a look at my P4 presentation. Maybe there's something good in it :D // plagiarising myself
      Design decision: Using registers rather than digest packets so that I can do that transparent software router trick super easily.
******* What was horrible:
        existing Python control plane API sucked, so I rolled my own
        - tables: bugs in interpretation of the values
        - everything was hard-coded
        - only 32-bit registers supported, but that goes all the way to the C API and the bus
*** TODO Implementing the parser
    Things that were horrible here (TODO write how I solved them!):
    - var length shit
    - reject behaving contrary to even the NetFPGA devs' expectation (TODO link to issue)
    - timing
***** the funny 5-stage story
      (include deparser here, because this is the reason why deparser was interesting)

      1. P4 has header stacks, gonna use header stacks.
      2. Header stacks not supported. => Stick the parts of the path before and after the current HF into a varbit thing.
      3. varbit not supported. => Skip the bits and use `XilinxStreamSwitch` to not lose them on the other end.  
         * explain changing template?
      4. Even skipping sizes that aren't compile-time constants not supported. => Loop in the parser (cycle in the state machine)
      5. Weird compiler bug on cycles (generates invalid sdnet code) => Unroll the loop and create $K$ separate states for parsing paths long $1...K$.
      5. Doesn't build for K > 16. => Do my $\sqrt{K}$ two-stage thing.
         => Show spacetime before & after.
***** the final design
      parser state machine diagram
*** TODO Hop field MAC validation
***** MAC
      adding extern (pipelined! <-- took forever to find out)

      Specifically, SCION uses the AES-CMAC function as specified by RFC 4493. It needs to MAC at most 2 at most 256-bit blocks per packet, which translates to  AES-128-ECB computations per packet.
***** timestamp
      just write clock by control plane
*** TODO Working around compiler/toolchain bugs
    unfortunately, this was enough of an issue to warrant a separate section in this thesis

*** TODO Meeting timing constraints
      - TODO example of data dependency graph and how I optimised it
* [0/4] Results
  What am I supposed to put here here?
  Ideally: It's effing fast and it's running in production :D And here are the pictures about how effing fast it is. Also about timing and utilisation and perhaps power consumption.
  # > What happened (objectively)?
  # > Do not interpret, simply state the facts.
  # > Let's be honest: the first thing most of us do when skimming a paper is look at the figures. If your key results can be presented in figures, then start with that, and structure your paper around that.
*** TODO Throughput
    pretty much my magic dashboard
    (include queue sizes)
*** TODO Latency
    if I can
*** TODO Fraction of real traffic sent to CPU
*** TODO Resource usage
    ideally also per-component
***** TODO FPGA area
***** TODO Power consumption
* [0/4] Discussion
  # > Results are objective, but science isn't about listing data, it's about extracting meaning from what we observe.
*** TODO Why do we see the results we see?
    TODO what do we see? :D
    Because this is "SCION as a library", I should talk not just about the BR's performance, but also about the characteristics of the parts on their own.
*** TODO Guidelines for high-speed packet processing
    see TODO something in [[*Background and Related Work]] for general intro to FPGAs
***** what's easy and what's hard from the "what you want to do" viewpoint
***** insights about P4 => HDL translation
******* Timing
        - inout parameters correspond to long paths => timing problems
        - CAM tables are kinda expensive (~0.1ns)
        - TODO how to find the critical path?
        - example of data dependency graph and optimising it
*** TODO Implications for the SCION protocol
    TODO this is a bit complicated... I am providing suggestions, but the actual
    things that will make it to the next version of SCION aren't my work, they are
    someone else's work that takes into account my suggestions. How do I put that
    here?
***** TODO What SCION does right
******* Avoiding lookup tables
        show area of a CAM table
        and if I have too much free time, do a power consumption measurement
***** TODO What should be improved
******* TODO Defining maximum sizes
        Currently, the maximum path length in the packet header is unreasonably
        large (the 8-bit offset fields allow for up to 256*8 = 2kB offset), and
        the hop field length is virtually unlimited (the continue flag signals
        whether we need to keep reading, and there is no maximum length defined).
        In hardware, in order to enable pipelining, we need to create buffers of
        the "worst case" size.
        This consumes FPGA area (thereby increasing costs and possibly energy
        consumption) and, due to processing in fixed-size blocks, increases
        latency.
        Therefore, these should be limited. We propose the following:
        - limiting the maximum number of hops to some "reasonable" value, such as 64
        - limiting the maximum hop field size to e.g. 16 bytes
******* TODO Avoiding variable lengths
        - good: pad to a nice number (currently 8, in the future SCION will pad to 4)
        - ATM HFs can be any multiple of 8 bytes, in the future (thanks to the
          change to 4 bytes) SCION will have only 12-byte HFs
******* TODO Avoiding implicit lengths
        addr type
******* TODO Consider re-thinking MAC chaning for peering paths
        In the case of peering paths, bla TODO bla
*** TODO what else have we learned?
* [0/6] Future work
*** TODO Completing the feature set
*** TODO Higher throughput
    terabit router
*** TODO Running in production
*** TODO Adding COLIBRI and EPIC
*** TODO Power requirements optimisation
*** TODO Other high-speed SCION applications
    other potential uses for my "SCION as a library": e.g. smart NICs with P4 in them => very fast end hosts
* [0/1] Conclusion
  # Bring it back to the big picture. How do your results fit into the current body of knowledge?
  # Most importantly, how can these results help you ask better questions?
  - high-security Internet protocols, and especially SCION, can feasibly be forwarded at high speeds
  - we see no major obstacles for implementing a very high throughput thingy
    (order of Tbps), and the minor things are going to be cleared up with the
    data plane redesign that incorporates my suggestions
  - P4 is an adequate language and though not everything is perfect, it is a
    useful tool that indeed helps achieve a quicker development cycle
  - we are looking forward to having more mature HW targets and toolchains, and
    we think there is much promise in continuing this work with those

#+begin_export latex
\bibliographystyle{abbrv}
\bibliography{bibliography}

\appendix
#+end_export

* Footnotes

[fn:5] SCION Control Message Protocol: the equivalent of ICMP in SCION. These packets should be rate-limited, and in future versions of SCION, they may become source-authenticated (i.e. require additional crypto).

[fn:4] In addition to "standard SCION", SCION also supports packets with end-to-end bandwidth reservations, and source-authenticated packets. For these, the verification information is different. In this work, we only implement the normal mode, and will mention the other modes only very briefly.

[fn:3] Autonomous System: a network or collection of networks that managed and supervised by a single entity or organization. An ISP's network is an example of an AS.

[fn:2] Application-specific integrated circuit: an integrated circuit customized
for a particular use. Since ASICs are custom-built, they can be highly
cost-effective and energy-efficient, assuming a sufficiently large deployment.

[fn:1] Field-programmable gate array: a chip with many programmable logic blocks
and programmable interconnects that can be used for hardware prototyping.

# Local Variables:
# org-confirm-babel-evaluate: (lambda (lang body) (not (string= lang "emacs-lisp")))
# after-save-hook: org-latex-export-to-latex
# End:
