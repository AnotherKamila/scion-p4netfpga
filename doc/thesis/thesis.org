#+TITLE:  Line-rate packet forwarding for the SCION future Internet architecture
#+AUTHOR: Kamila Součková
#+DATE:   August 19, 2019
#+DESCRIPTION: Master Thesis
#+INCLUDE: thesis-setup.org

# TODO somebody should do something so that my TOC fits on one page

#+LATEX: \frontmatter
* [1/1] Abstract
  CLOSED: [2019-07-15 Mon 15:45]
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
  The SCION future Internet architecture is designed to provide route control,
  failure isolation, and explicit trust information for end-to-end communication.
  Its viability has already been demonstrated in production, but to work
  at Internet scale, it is necessary to make it perform at high speeds, reduce
  costs, and evaluate suitability for eventual implementation in hardware.
  This project implements a SCION border router capable of line-rate packet
  forwarding, currently running on an FPGA target.
  It uses P4: a new language for programming packet forwarding planes.
  This enables target independence, a quicker development cycle, and a more
  modular approach.
  Based on this work, we suggest changes to the SCION data plane that allow for
  more efficient processing in hardware.
* [0/1] Acknowledgements
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
  TODO
#+TOC: headlines 1
#+LATEX: \mainmatter

* [3/3] Introduction
  # [In field X, we still don’t understand Y & Z.]
  # Write a summary of the question(s) you are trying to answer.
  # What is the state of the world before your research came along?
  # Also, answer the harsh but important question: Who cares?
  # In writing this, you can start general, but make sure you clearly define the “before” state of the world’s knowledge for the specific area this paper is addressing.
*** DONE Why SCION?
    CLOSED: [2019-07-16 Tue 15:25]
    Today's Internet, based on IP and BGP, was conceived in a very different
    environment, with very different requirements and very different
    assumptions. Meant to be a research network, it assumed that
    access was not widespread (as only large institutions could afford a
    connection), that all entities connected to it trusted each other (and had
    out-of-band means to deal with misbehaviour),
    and that it would not grow large enough for outages to become difficult to
    manage.
    Considering these facts, it has scaled surprisingly well, but nowadays we
    are living in a very different world.

    Today, everyone is connected and everyone has their data on the Internet.
    With the huge number of connected entities, many of which have conflicting
    interests, trust can no longer be global and implicit.
    Users want control over their data, ISPs want control over their services,
    and states want to protect their infrastructure from outside actors.
    At this scale, convergence after path failure takes too long, and
    large-scale outages due to BGP route leaks are happening almost weekly.
    Furthermore, attacks on the Internet infrastructure, e.g. DDoS attack or BGP
    route hijacks, are becoming more and more common.
    In today's world, these issues can no longer be tolerated.

    In the future, the Internet will become even more critical. Automation (such
    as drones, self-driving cars, or remotely operated robots) will depend on
    the availability and security of the Internet.
    As more and more data moves online, trust will become even more of an issue.
    We will need ways to satisfy new requirements such as geo-fencing, which
    cannot be adequately fulfilled with the current Internet architecture.
    And as malicious actors get more and more sophisticated and powerful, their
    attacks will get even harder to stop.
    Therefore, we will need to move to an Internet architecture that is
    resilient to both unintentional failures and malicious attacks,
    can provide explicit trust information to the end users,
    and gives the end users as well as institutions control over whom they trust
    and what happens with their data.

    There have been may attempts to fix the IP+BGP-based Internet TODO[cite
    something], but patching an architecture designed with entirely different
    assumptions simply cannot solve all the problems TODO[cite something].
    Additionally, the IP-based approach also has scalability issues due to
    requiring very large routing tables, and this is bound to get worse in the
    future.
    Therefore, the SCION project chooses to build a clean-slate Internet
    architecture, with the goals of scalability, route control, failure
    isolation, and explicit trust information in the design.
*** DONE SCION right now
    CLOSED: [2019-07-16 Tue 17:16]
    Thanks to a well-thought-out design, as well as "real-life" considerations
    such as deployment, transition strategy, and engagement with industry, SCION
    is currently running in production in several locations TODO[cite].
    Additionally, a planet-wide research network for testing SCION is running
    thanks to SCIONLab TODO[cite SCIONLab paper].
    These use cases have proven that SCION is in fact suitable for real-world
    usage.
    In the near future, several ISPs are likely to start offering SCION
    connections to their customers.
    Therefore, considerations like throughput, cost-effectiveness, and energy
    efficiency are of great interest to many in the SCION community.

    The existing implementations of the SCION infrastructure, in particular the
    routers, run as applications on standard servers.
    This has enabled rapid development, as well as flexibility, and it will
    continue to be the primary approach until the protocol stabilises.
    However, with the current technologies, a software-based approach cannot
    achieve throughput above several tens of gigabits per second.
    Therefore, large-scale deployments would require many such routers, which is
    not cost-effective.
    From the research perspective, whether SCION can even in principle run at
    line rate, and what hurdles must be overcome, are still open questions.

    Especially thanks to the real-world deployments, SCION is now
    mature enough to lend itself to implementing in hardware.
    Though the current version of the protocol is very unlikely to be the final
    one, it would be useful to get an initial hardware-based implementation,
    mainly in order to evaluate the protocol's suitability for hardware.
    A successful hardware-based implementation would also be a good answer to
    the "can it run at line rate?" question, which would further increase the
    probability of deployment with commercial ISPs.
*** DONE Aims of this project
    CLOSED: [2019-07-18 Thu 13:37]
    TODO is this better inline like this, or in an item list?

    The first aim of this project is *implementing a border router capable of
    forwarding SCION packets at line rate*.
    We will target a NetFPGA SUME board, which will (in the ideal case) allow us
    to forward up to 40Gbps.
    The border router is the crucial building block of the SCION data plane.
    Therefore, having a high-speed prototype will open the doors to large-scale
    data transfers, as well as prove that infrastructure providers (such as
    ISPs) will be able to scale to meet the needs of many customers without
    incurring very high costs.

    Additionally, we wish to keep the work target-independent (as much as
    possible), and thereby create a "library for line-rate SCION" for a variety
    of targets and use-cases.

    An implementation targeting an FPGA[fn:1] is a good first step for
    evaluating the feasibility of building "SCION on chip": much of the design
    process is the same with FPGAs as with ASICs[fn:2].
    Therefore, the second aim of this work is to
    *confront SCION with hardware design expertise, and consider the possibility
    of building faster, more efficient designs in the future*.
    The knowledge gained in the process of implementation on the NetFPGA will
    allow us to better understand the requirements of running SCION in custom
    hardware, and predict whether a very high-speed and energy-efficient ASIC
    implementation could be built.
    As being able to run in hardware is a hard requirement for the success of
    any network-layer Internet protocol, knowing more about this question is
    crucial to the development and deployment of SCION.

    With the knowledge gained during the implementation, we will be able to
    fulfill the third aim of this project: *providing suggestions for the SCION
    protocol that would result in more efficient hardware implementations*.
    Running in hardware has been a consideration in the design of SCION from the
    beginning, but an actual implementation, rather than abstract reasoning, is
    likely to uncover opportunities for further improvement.
    Doing this early, before SCION has become widely deployed, allows us to
    implement any changes needed without having to worry about
    backwards-compatibility and enter the "real-life deployment" sphere with an
    already optimised protocol.
* [4/5] Background and Related Work
  In order to achieve this project's aims, we need to work in the intersection of
  several fields: among others network security, network protocols, software
  engineering, and hardware design.
  This chapter introduces what concerns us in each of the relevant areas, and the
  following chapters build on this information.
*** DONE SCION data plane
    CLOSED: [2019-07-23 Tue 17:47]
    SCION is a clean-slate Internet architecture designed for
    route control,
    failure isolation, and
    explicit trust information
    for end-to-end communication.
    For a comprehensive presentation of the SCION architecture, see cite:scion-book.
    In this section, I will introduce the aspects of the SCION data plane relevant
    for this work.
#+begin_comment Ain't nobody got time for this stuff
# The name SCION stands for "scalability, control, and isolation on
# next-generation networks", which summarises the aims of SCION: we will discuss
# below how these aims are achieved. First, let us have a look at how SCION works.
# ***** Overview of the SCION architecture
# ******* Isolation Domains
# At the core of SCION is the concept of *isolation domains* (ISDs): an ISD is
# an autonomous collection of ASes[fn:3] that manages its own routing
# infrastructure and root of trust (both for routing and PKI).
# Actors outside of the ISD are unable to influence either routing or trust within
# the ISD.
# The exact mapping of ISDs to physical world entities is a topic for further
# research, but for simplicity, we can imagine for the sake of this explanation
# that an ISD could map to a country or union of countries that share common
# jurisdiction and agreements.
# Multiple ASes within the ISDs run the *ISD core*, which is responsible for
# providing core routing infrastructure, as well as the PKI.
# These could be e.g. government-operated or large commercial ISPs.
# Non-core ASes then provide connectivity to end users, while relying on the
# services provided by the ISD core.
# The ISD is a self-contained entity, with everything needed for inter-ISD routing
# contained within the ISD.
# Therefore, the ISD is isolated from misconfiguration or misbehaviour by outside
# entites, which makes the network more stable and reliable.
# Furthermore, creating the hierarchy of separate ISDs instead of one global
# network helps with scalability, as described in TODO somewhere below.
# #+CAPTION: Multiple isolation domains (ISDs). Communication within each ISD is entirely handled within the ISD, and communication among different ISDs is facilitated by the ISD core. Note that while control plane communication always flows only among core ASes, inter-ISD data transfer is possible also over non-core links.
# #+NAME:   fig:isds
# [[./img/isds.png]]
# ******* Path discovery
# ******* Path selection
# ******* Packet forwarding
# The data plane blablabla.
#+end_comment
***** Packet-carried forwarding state
      In order to scale without the need for state on routers (specifically large
      routing tables), SCION puts all information needed for packet forwarding into
      the packet header.
      In particular, the user-selected path that the packet needs to take through the
      network is present in the header, as a stack of /hop fields/ (HFs).
      This means that the packet headers are variable-size and can be somewhat large
      -- this is the tradeoff SCION makes to avoid large and potentially inconsistent
      routing tables in routers.

      Each HF in the path corresponds to an AS-level hop.
      It encodes the ingress and egress interface in its AS,
      verification information used by the AS to check that the end host is
      allowed to use this hop,
      the expiration time for this HF (which must be checked),
      and some additional information.
      The exact HF format is described in TODO[ref SCION book].
      In order to forward the packet, the router only needs to look at the
      "current" HF, i.e. the one meant for this AS.
      Therefore, the SCION header contains a pointer to the current HF.
      This is initially set to the first one in the path, and every egress
      border router increments it after processing it, so that a router can find
      its HF without parsing the whole path.
***** Hop field verification
      Allowing the end host to assemble the path is great for giving the end
      host control, but for various reasons ASes may need to enforce routing
      policies.
      Therefore, end hosts must not be allowed to create "any" paths, only ones
      compliant with the policies of the ASes involved.
      In order to enforce this at line rate and without needing much state on
      the routers, SCION requires the HFs to contain verification
      information.
      For standard SCION, this information is a cryptographic MAC keyed by an
      AS-specific secret key.[fn:4]
      The AS distributes the HFs including this pre-computed MAC during path
      discovery, and therefore if a hop field in the end-host-created path
      contains a valid MAC, it is proof that the end host got this HF from the
      creator AS.
      The MAC for a HF is computed over itself and the HF occuring
      previously in the path (see figure [[fig:mac-chaining]]), so that the end host
      cannot arbitrarily join multiple valid path segments into a single path if
      it has not been explicitly allowed.
      The MAC verification is based on AES-CMAC TODO[cite the RFC], because with
      dedicated hardware, computing AES can be done very efficiently at line
      rate. TODO[would be great to have something to cite here -- look for what
      Adrian ended up citing when he asked me what to cite :D]
      Because the forwarding is otherwise rather simple, achieving a
      sufficiently fast HF verification routine will be one of the more
      interesting aspects of our implementation.

      #+NAME:   fig:mac-chaining
      #+CAPTION: TODO somebody should write something here.
      [[./img/mac-chaining.svg]]
      # TODO somebody should change the colours so that the whole HF is coloured,
      # and should copy the fixed version back to the presentation.
      # (and then should change this picture to render correctly with pdf_tex)
***** IP overlay
      In order to enable inter-operability with existing networks, SCION packets
      may use an IP/UDP overlay.
      The software border router currently requires this, as it uses a UDP
      socket to get SCION packets.
      Therefore, our implementation must accept SCION within IP, and must send
      out packets wrapped in the correct IP/UDP overlay, i.e. the next hop's IP
      address and UDP port.
      In the future, SCION will also run directly on top of L2 (when given a point
      point-to-point link).
      Our implementation should therefore either support both, or make it easy
      to add direct SCION over Ethernet links in the future.
***** Putting it all together: Border router behaviour
      TODO[not sure if this should be here or later on in the implementation: it
      makes sense to have it here, but what if someone isn't reading this
      section :D]

      In accordance with the above, our border router must do the following:
      1. Extract and parse the current HF according to the offset information
         in the offset header.
      2. Verify the ingress interface and the incoming IP overlay.
      3. Check that the HF is not expired.
      4. Validate the HF MAC.
      6. Update the HF offset information.
      5. Update the IP overlay header.
      7. Select the output port corresponding to the egress interface and send the packet out.
***** Related work
      The reference software router is available at TODO cite scionproto github.
      Since this runs in software and is not optimised for performance, it can
      achieve a few Gbps on normal hardware.

      We are aware of ongoing work by various groups: one creating a high-speed
      software implementation (several tens of Gbps), and two hardware-based
      implementations: one targeting an FPGA and programmed in Verilog, and one
      targetting a programmable switch (due to the limitations of the hardware,
      this one will support "SCION with caveats").
      At the time of writing, none of this work has been published.
*** DONE High-speed packet forwarding
    CLOSED: [2019-07-23 Tue 22:28]
    TODO this whole section could be replaced with a picture like this:
    #+begin_src text
      ^           : can do SCION to the right of this line
      | * ASIC    :
    p |      * programmable switch
    e |           :
    r |           :
    f |           :
    o |           :    * FPGAs
    r |           :
    m |           :
    a |           :
    n |           :
    c |           :        * eBPF
    e |           :         * DPDK
      |           :            * "normal" SW
      +-------------------------->
           flexibility
    #+end_src
    Should I just do that and have significantly less text?

    # This section is kinda terrible, because there are too many words in it,
    # but I'm afraid I don't have enough time to write less.

    There are multiple approaches that enable high-speed packet processing.

    On the software side, the main approaches are eBPF and DPDK.

    *eBPF* is an open-source in-kernel user-programmable virtual machine,
    originally introduced in BSD and later ported to GNU/Linux.
    It allows the user to implement their own packet processing rules without
    losing performance due to copying to userspace and back.
    The performance of eBPF on modern hardware is on the order of
    10 Gbps.

    *DPDK*, the Data Plane Development Kit, is a set of data plane libraries
    and network interface card (NIC) drivers that enables fast packet processing in userspace.
    It abstracts the hardware and software environment in order to enable
    target-independent implementations.
    Its performance on modern hardware is also on the order of 10 Gbps.

    To achieve higher efficiency and cost-effectiveness, using a hardware
    approach is often preferred.
    For mature protocols (i.e. ones that are very unlikely to change), it is
    preferred to build a custom ASIC, i.e. a chip with the exact circuitry
    required to perform the function.
    Examples of ASICs used in networking are Ethernet controllers (also on
    NICs in PCs) or IP prefix matching tables in dedicated router
    hardware.

    *ASICs* have very good performance characteristics and they are
    cost-effective at large quantities, but the one-time development costs of
    ASICs are extremely high and if the protocol changes, an ASIC cannot be
    reprogrammed.
    Therefore, for new protocols such as SCION, we need to look at
    programmable hardware.
    One flavour is programmable network switches: a fixed structure with some
    programmable elements.
    An OpenFlow switch is one example: the processing pipeline is fixed, but
    one can to an extent choose which fields are matched and what action is
    performed based on the match.
    Recently, more flexible programmable switches based on the P4 language
    (see [[*P4]]) have become available.
    These have a fixed architecture, i.e. the general "shape" of the
    processing pipeline: an example would be
    "parser → checksum verification → match-action pipeline →
    checksum calculation → deparser".
    The functionality within each of these blocks is programmable to an
    extent, but still limited by the capabilities of the underlying hardware.
    In exchange for these limitations, the hardware can be optimised and can
    achieve throughput up to several Tbps.

    Unfortunately, currently available programmable switches do not have all
    capabilities required for SCION: notably, the high-performance switches
    miss a cryptographic functions module, without which we cannot efficiently
    implement the AES-based HF MAC.
    Further, programmable switches do not provide much insight into the
    internals of the execution (and any such insight would anyway be limited
    to the specific switch), so with these, we would not be able to discover
    the bottlenecks and find opportunities for optimising the SCION protocol
    for hardware in general.

    A good tradeoff between flexibility and performance, which additionally
    shows more of the hardware design process, are *FPGAs*.
    Designing for an FPGA gives us the full power (and responsibility) of
    designing fully custom hardware: 
    we are not limited to whatever the manufacturer included, and
    if we need an AES module, we can add an AES module.
    The full programmability of the circuit comes at the cost of performance:
    assuming a good design, a single FPGA can handle on the order of 100 Gbps
    (which is about an order of magnitude above software, and about an order
    of magnitude below programmable switches and ASICs).

    When designing for an FPGA, we have visibility into the various parts of
    the system, and can see which parts are "difficult" to implement
    efficiently.
    Because the design process for FPGAs is the same as the first steps for
    creating an ASIC, it is reasonable to assume that things problematic on
    FPGAs would also be problematic on an ASIC.
    This allows us to make good guesses about the difficulties in hardware in
    general, and therefore propose generally useful changes to the SCION
    protocol.

    Due to hardware availability, the flexibility vs. performance tradeoff, as
    well as the insights that can be gained in the design process, we have
    chosen an FPGA for our work.
*** DONE NetFPGA
    CLOSED: [2019-07-29 Mon 10:29]
    The NetFPGA is a family of open-source hardware and software for prototyping
    of network devices.
    They are FPGA-based devices with several high-speed Ethernet ports.
    Being FPGA-based implies that these devices are fully programmable.
    Therefore, we will be able to include all the required functionality, such
    as parsing of SCION packets, AES-based MAC computation, timestamp
    validation, and communication with the control plane.

    Their newest (as of 2019) product, the NetFPGA SUME cite:sume, has 4 ports
    with 10G Ethernet, thus enabling a total throughput of 40 Gbps.
    It incorporates Xilinx's Virtex-7 690T FPGA, which is a high-end FPGA
    suitable for large projects.
    Due to this, and the availability of a P4 toolchain (see [[*P4]]) targeting
    the NetFPGA SUME, we have chosen to use this hardware for our project.
*** DONE P4
    CLOSED: [2019-08-01 Thu 12:02]
    P4 is a programming language for specifying packet processing pipelines.
    Building on previous software-defined networking efforts, it allows switches
    to be reprogrammed by the end user.
    It is target-independent, and therefore can in principle be used for
    programming anything from software switches to high-performance ASICs with
    minimal changes to the program.
    It is general enough to express the processing of almost any reasonable
    network protocol, including SCION, and high-level enough to spare us from
    target-dependent implementation details such as manually managing
    pipelining.

    For programming FPGAs, P4 enables a much more high-level approach compared
    to traditional hardware description languages (HDLs) such as VHDL or Verilog.
    While the traditional HDLs are more general and give the user far more
    control, P4's focus on a single purpose (packet processing) enables it to
    abstract away many common features of packet processing pipelines, and lets
    the programmer focus on the interesting features.
    Further, its choices about which features are not supported (such as
    unbounded loops or arbitrary array access) enable the P4 compiler to
    guarantee line rate processing ("if it compiles, it will run fast").
    Our initial examination of P4 suggests that it provides appropriate
    abstractions, and that the benefits of a faster development cycle,
    maintainability for software engineers, and target independence
    outweigh the loss of fine control for the use case of building a SCION
    router prototype.

    P4 is a relatively new language (the specification for P4_16, the version we
    use, was published in May 2017).
    Therefore, the first interesting question is P4's suitability for describing
    non-traditional network protocols such as SCION.
    Beyond those concerns, the toolchains for targeting specific hardware, and
    especially the NetFPGA, are at this point experimental and not well tested
    (as we will see in chapter [[*Implementation Challenges]]).
    Nevertheless, the abstractions offered by P4 may be worth it, especially
    because the "new, untested technology" problems will likely get less severe
    in the future, and therefore having a P4 implementation for SCION will become
    more and more useful over time.
*** TODO [0/4] Introduction to designing for FPGAs
    TODO is this a good name for this chapter?
    The design process for an FPGA is very different from software engineering.
    Though this is a difficult task, in this section we attempt to provide an
    overview of it from the perspective of a "converted" software engineer.
***** TODO [0/2] Concepts:
******* TODO FPGA area
******* TODO Timing constraints
***** TODO Overview of the process
***** TODO think in space, not time
      - everything happens at the same time
      - TODO didn't I start writing this down somewhere else? either tiddlywiki or website :D -- find it!
***** TODO resources / limiting factors
      - Area instead of # of instructions
      - Timing => path length + logic complexity
* [0/4] Aims
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
TODO maybe I don't even want to have this chapter, but just have the "Aims"
section in Introduction,
because (contrary to the SDN-CH presentation) I am not selling this as "I'm
going to enlighten you about P4" and then two of these things look less relevant
and I suppose it makes sense to say this in Introduction anyway and blah.
Hi reviewers, your opinions on this matter are especially welcome :D
#+begin_comment Ain't nobody got time for this
# *** TODO Deployable SCION BR
#     - forwarding at line rate => with NetFPGA, that is 40Gbps
#     - usable with real traffic
#     - integrated with existing SCION infra (control plane, monitoring/metrics)
# *** TODO SCION as a library
# *** TODO Guidelines for high-speed P4
#     or gaining experience or whatevs
#     Listen to my advice and you too can process packets at high speeds, even if you are not a hardware person.
# *** TODO Optimising the SCION protocol for HW
#+end_comment

* [1/2] Design overview
  The border router's algorithm, as outlined in section [[*Putting it all together:
  Border router behaviour]], is as follows (more details have been added here):

  1. Identify the packet as SCION and parse the SCION common header.\\
     If the packet is not SCION, send it to software.\\
     If the parsing fails, drop this and generate an SCMP[fn:5] error packet.
  2. Extract and parse the current HF according to the offset information in the offset header.\\
     If the extraction or parsing fails, drop this and generate an SCMP error packet.
  3. Verify the ingress interface and the incoming IP overlay.\\
     If incorrect, drop this and generate an SCMP error packet.
  4. Check that the HF is not expired.\\
     If incorrect, drop this and generate an SCMP error packet.
  5. Validate the HF MAC.\\
     If incorrect, drop this and generate an SCMP error packet.
  6. If the packet destination is in this AS, forward it according to the intra-AS routing.\\
     If the HF contains the FWD_ONLY flag, drop the packet instead and generate an SCMP error packet.[fn:6]
  8. Update the HF offset information.
  9. Update the IP overlay header according to an egress interface ⇒ IP overlay data table,
     including recomputing IP and UDP checksums.
  10. Select the output port corresponding to the egress interface and send the packet out.

  TODO if I weren't lazy, this could be a fancy flow diagram.
  Hi reviewers, should it be a fancy flow diagram? (Maybe additionally to this
  text, because it's a lot of text.)

  Note that the "everything is fine" path is quite simple, but the error
  generation (which needs rate-limiting and may change significantly in the
  future) and local delivery (which needs additional configuration and state on
  the router for intra-AS routing) are more complicated.
  Therefore, a key design decision is to structure this project as a "really
  smart NIC": all packets which can be completely processed in the FPGA will be
  processed in the FPGA, and any packets which cannot be completely processed
  (for any reason) will be sent to the OS unmodified, through what looks like a
  normal network interface to the OS.
  The OS-visible interface will, further, pass through any packets sent to it by
  the OS, so that our implementation does not need to know anything about the
  unprocessable packets and any replies.
  This, together with SCION's stateless design, enables us to run the software
  SCION router unmodified and completely unaware of the fact that the FPGA
  taking care of most of the traffic.
  Thus the code running on the FPGA can be kept relatively simple, as it does
  not need to handle any of these special cases.
  Additionally, with this approach, we can start with the very simple "pass
  everything through to the OS" program, and incrementally move more and more
  functionality into the FPGA, which greatly helps with development speed.

  Figure TODO shows the components of our design.

  TODO diagram of the components:
  show pic with data plane + normal SCION SW router + my thin control plane

  this is awesome because:
  - modularity: blablabla
  - simplicity: everything that doesn't have to happen at line rate, such as error packet generation, all control plane packet processing, even ARP and stuff, is handled transparently without any work on my side
  - "upgradeability": if the control plane gets extended / changed, I don't care, as long as the forwarding path format (which isn't as likely to change) is the same
  - enables incremental development of the HW design: start with just passing through everything, then add more and more features that don't have to go to CPU
* [0/7] Implementation Challenges
  # originally wanted to divide this into parser, validation, forwarding, etc... but
  # I don't think that makes much sense, as e.g. timing or stupid compiler were a
  # problem across the whole thing
*** TODO Target independence
*** TODO Incremental development
***** fake network interfaces over DMA
***** control plane
      twisted => trivially composable => trivial to add new features, mix&match
*** TODO Control plane
    independent modules, often complementary to the P4 modules => something something modularity runs across the whole stack
      Perhaps also TODO have a look at my P4 presentation. Maybe there's something good in it :D // plagiarising myself
      Design decision: Using registers rather than digest packets so that I can do that transparent software router trick super easily.
******* What was horrible:
        existing Python control plane API sucked, so I rolled my own
        - tables: bugs in interpretation of the values
        - everything was hard-coded
        - only 32-bit registers supported, but that goes all the way to the C API and the bus
*** TODO Implementing the parser
    Things that were horrible here (TODO write how I solved them!):
***** reject behaving contrary to even the NetFPGA devs' expectation (TODO link to issue)
***** timing
***** the funny 5-stage story
      (include deparser here, because this is the reason why deparser was interesting)

      1. P4 has header stacks, gonna use header stacks.
      2. Header stacks not supported. => Stick the parts of the path before and after the current HF into a varbit thing.
      3. varbit not supported. => Skip the bits and use `XilinxStreamSwitch` to not lose them on the other end.  
         * explain changing template?
      4. Even skipping sizes that aren't compile-time constants not supported. => Loop in the parser (cycle in the state machine)
      5. Weird compiler bug on cycles (generates invalid sdnet code) => Unroll the loop and create $K$ separate states for parsing paths long $1...K$.
      5. Doesn't build for K > 16. => Do my $\sqrt{K}$ two-stage thing.
         => Show spacetime before & after.
******* TODO var length shit
Unfortunately, the SDNet P4 compiler implements only a subset of P4, which has
created unexpected challenges when implementing SCION.
The biggest issue [HOPEFULLY :D] was that at the time of writing, with P4-SDNet
the parser cannot work with any variable-length data: this includes not only
=varbit<n>= types, but also header unions, and -- most importantly -- header
stacks.
Furthermore, it is unable to even skip over variable-length parts of the packet.
Simply put, all packet offsets must be compile-time constants.
This poses a problem for SCION: the path in the packet is variable length (it
can contain any number of hops).[fn:varlen]
Therefore, the parser cannot easily deal with the path in the SCION
packet.[fn:cantparse]

To get around this problem, we employed the following steps:

First of all, we opted to design the parser so that it parses only the actually
needed data: while the path can be arbitrarily long, any single BR only needs to
process $O(1)$ hop fields (usually one, or two in case of a shortcut path).
This not only makes it possible to compile for the NetFPGA, but also improves
performance on other targets.

Next, we needed to solve the problem of emitting headers we have skipped:
using only the standard features
of P4, it is impossible to deparse parts of the header which have not been
parsed. (The payload is copied without being parsed, but the payload is defined
as anything *after* the last thing we parsed -- so if we skip parsing something
in the header, it is lost and we are unable to emit it on the output interface.)

The solution on the NetFPGA is to use the non-standard ~packet_mod~ feature of
P4-SDNet, as this (unlike the standard deparsers) allows to modify the existing
header instead of creating it anew, thereby allowing me to not lose the skipped
parts of the header.

Using the ~packet_mod~ feature is not straightforward, either: we needed to
switch to the ~XilinxStreamSwitch~ architecture, as this feature is not
available in the ~SimpleSumeSwitch~ architecture that is the default on the
NetFPGA.
This required modifying the Verilog wrappers provided by the NetFPGA developers.

Obviously, using a non-standard SDNet-only feature means that with this
approach, the program would not compile on a standard P4 compiler.
However, standard P4 compilers (unlike the P4-SDNet compiler) tend to implement
parsing variable-length headers.
Therefore, we are able to emulate ~packet_mod~ for standard compilers by adding
an extra struct to keep track of the "skipped" parts of the headers, and instead
of skipping them, we parse them into the (variable-length) fields of this extra
struct.

We can use the C preprocessor to hide this difference, thereby keeping our
code portable while being able to use ~packet_mod~ where available.
This not only allows us to parse the variable-length SCION packet on the
currently incomplete P4-SDNet compiler, but also allows us to harness the
performance benefits of the ~packet_mod~ feature on any target where it is
available.

To make this approach work, the last step is to turn all packet offsets,
including the ones used only for skipping, into compile-time constants.
Fortunately, SCION hop fields are constant length.
Therefore, if we assume a maximum path length $K$, let's say $K = 50$, there are
only $O(K)$ many options for how many different sizes we might need to skip.
Therefore, we can use the C preprocessor to "unroll" the parser and create
separate states for skipping $1$, $2$, $...$ hop fields.
This causes an $O(K)$ increase in FPGA area usage, but no latency increase --
our logic becomes wider, but not deeper.

The same tricks must then be applied in the ~packet_mod~ deparser.

The maximum path length $K$ that our BR can handle then becomes a linear
function of the NetFPGA's area (after subtracting the area we use for the rest
of the design): the largest $K$ we can use is determined by what we can fit.
Since our implementation uses the area quite efficiently (TODO number/reference)
and the NetFPGA is rather large, we are able to fit a $K = TODO$ on the NetFPGA
SUME.


[fn:varlen] The SCION host addresses are also variable-length, as the address
type tag in the common header defines what kind of address it is.
For this case, we opted to use the C preprocessor to conditionally replace the
union with a struct with three fixed-length fields (one for each possible type
of address), only one of which is parsed and made valid for a given packet.
(This causes a small increase in FPGA area usage, but any other solution would
be significantly more complex, so this is a good tradeoff.)

[fn:cantparse] In fact, it would be possible to parse the whole SCION packet by
using the C preprocessor to "unroll" the parser at compile time, and parse the
path segments into ~struct~'s with fields such as =hop1=, =hop2=, ... (size
fixed at compile time).
However, this would make actually using the fields very difficult, as I would
need more preprocessor magic to index into such a struct; and additionally it
would drastically increase my FPGA area usage.

***** the final design
      parser state machine diagram
*** TODO Hop field MAC validation
***** MAC
      adding extern (pipelined! <-- took forever to find out)

      Specifically, SCION uses the AES-CMAC function as specified by RFC 4493. It needs to MAC at most 2 at most 256-bit blocks per packet, which translates to  AES-128-ECB computations per packet.
***** timestamp
      just write clock by control plane
*** TODO Working around compiler/toolchain bugs
    unfortunately, this was enough of an issue to warrant a separate section in this thesis
    see [[*Implementing the parser]]
***** HW is silly
******* sometimes DMA may need an extra reboot?
*** TODO Meeting timing constraints
    The various costly workarounds as explained in the previous sections of this
    chapter, together with some questionable design choices in the P4-NetFPGA
    base design[fn:7], take up almost all of the FPGA area.[fn:8]
    Due to this, the place and route step of the design process has difficulty
    satisfying timing constraints.

    Even after more than a month of optimisation, the full design has a negative
    slack of about 0.08ns: running on a 200MHz clock requires all paths to take no
    longer than 5.0ns, and in the full design the longest path requires 5.08ns.
    At this point, the FPGA is too full for any optimisations to help: all of our
    attempts just shifted the problem from one place to another, but did not solve
    it.

    Nevertheless, during the optimisation process, we have learned a great deal:
     - TODO example of data dependency graph and how I optimised it
* [0/4] Results

  What am I supposed to put here?
  Ideally: It's effing fast and it's running in production :D And here are the pictures about how effing fast it is. Also about timing and utilisation and perhaps power consumption.
  # > What happened (objectively)?
  # > Do not interpret, simply state the facts.
  # > Let's be honest: the first thing most of us do when skimming a paper is look at the figures. If your key results can be presented in figures, then start with that, and structure your paper around that.

  Due to inadequacies in the P4-NetFPGA toolchain as explained in [[*Meeting
  timing constraints]], we have not been able to test the full system.
  Therefore, we do not present results for the full design: instead, we show the
  data for the various components of the design, and we draw conclusions based
  on these and our knowledge of how composing systems in FPGAs changes
  performance.
*** TODO Throughput
    pretty much my magic dashboard
    (include queue sizes)
*** TODO Latency
    if I can
*** TODO Fraction of real traffic sent to CPU
*** TODO Resource usage
    ideally also per-component
***** TODO FPGA area
***** TODO Power consumption
* [0/4] Discussion
  # > Results are objective, but science isn't about listing data, it's about extracting meaning from what we observe.
*** TODO Why do we see the results we see?
    TODO what do we see? :D
    Because this is "SCION as a library", I should talk not just about the BR's performance, but also about the characteristics of the parts on their own.
*** TODO Guidelines for high-speed packet processing
    see TODO something in [[*Background and Related Work]] for general intro to FPGAs
***** what's easy and what's hard from the "what you want to do" viewpoint
***** insights about P4 => HDL translation
******* Timing
        - inout parameters correspond to long paths => timing problems
        - CAM tables are kinda expensive (~0.1ns)
        - TODO how to find the critical path?
        - example of data dependency graph and optimising it
*** TODO Implications for the SCION protocol
    TODO this is a bit complicated... I am providing suggestions, but the actual
    things that will make it to the next version of SCION aren't my work, they are
    someone else's work that takes into account my suggestions. How do I put that
    here?
***** TODO What SCION does right
******* Avoiding lookup tables
        show area of a CAM table
        and if I have too much free time, do a power consumption measurement
***** TODO What should be improved
******* TODO Defining maximum sizes
        Currently, the maximum path length in the packet header is unreasonably
        large (the 8-bit offset fields allow for up to 256*8 = 2kB offset), and
        the hop field length is virtually unlimited (the continue flag signals
        whether we need to keep reading, and there is no maximum length defined).
        In hardware, in order to enable pipelining, we need to create buffers of
        the "worst case" size.
        This consumes FPGA area (thereby increasing costs and possibly energy
        consumption) and, due to processing in fixed-size blocks, increases
        latency.
        Therefore, these should be limited. We propose the following:
        - limiting the maximum number of hops to some "reasonable" value, such as 64
        - limiting the maximum hop field size to e.g. 16 bytes
******* TODO Avoiding variable lengths
        - good: pad to a nice number (currently 8, in the future SCION will pad to 4)
        - ATM HFs can be any multiple of 8 bytes, in the future (thanks to the
          change to 4 bytes) SCION will have only 12-byte HFs
******* TODO Avoiding implicit lengths
        addr type
******* TODO Consider re-thinking MAC chaning for peering paths
        In the case of peering paths, bla TODO bla
*** TODO what else have we learned?
* [4/6] Future work
  TODO it may or may not be a good idea to re-order these
*** DONE Completing the feature set / Adjusting for newer SCION versions
    CLOSED: [2019-07-24 Wed 14:28]
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    Due to difficulties with the NetFPGA's P4 toolchain, we currently do not
    implement everything in the current version of SCION, which means that a
    larger than necessary fraction of traffic must be handled by the CPU.
    Therefore, an obvious avenue for improvement would be to implement the
    missing parts of SCION, namely handling UP segments, shortcuts and peering
    paths.
    However, the handling of shortcuts and peering links may be simplified in
    the next version of the protocol, which will require modifications to this
    project's code anyway.
    Therefore, it is better to first accomodate the new protocol version (once
    it is finalised), and add support for all link types afterwards.

    Further, the current version of the project only supports overlays using
    IPv4, because unlike in IPv4, IPv6 checksums are computed over the whole
    packet, not just the headers.
    The P4-NetFPGA toolchain currently does not provide any way to compute with
    the packet body, so IPv6 checksums would require an unreasonable amount of
    effort to implement.
    The P4 code does contain support for IPv6 overlays and the checksum is the
    only missing piece.
    Therefore, enabling IPv6 overlays will be an easy improvement if the
    checksum becomes available (e.g. by targetting hardware with a different
    toolchain).
*** INPR Higher throughput
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    With the NetFPGA as our hardware target, we are limited to 40 Gbps by its 4
    10G ports.
    If not for that limitation, our design could achieve up to 51
    Gbps without any change (it processes 256 bits per cycle at 200MHz clock ⇒
    256*200e6 = 51e9).
    If not for the numerous costly workarounds, our design could run at a higher
    frequency, and with greater paralellism.
    Therefore, with a better toolchain, we may be able to achieve several
    hundred Gbps with a single FPGA of similar parameters as what we are using
    now.

    A SCION border router does not require any state other than static
    configuration, so the packet processing can be easily parallelised using
    multiple FPGAs.
    The only thing that needs to scale vertically is the switching itself, which
    can be done with speeds of several hundred Gbps with relatively affordable
    hardware (as long as we don't require the hardware to be programmable).
    Therefore, using several higher-throughput FPGA-enabled NICs for
    the packet verification and update, plus a non-programmable MPLS or IP
    switch for the switching (i.e. to handle buffering/queueing at high speeds),
    we could in principle scale to very high rates even without creating an ASIC.

    TODO The previous paragraph should actually go somewhere into [[*Discussion]]
    and just be referenced here.
*** DONE Running in production
    CLOSED: [2019-08-01 Thu 13:01]
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    Due to the problems explained in [[*Implementation Challenges]], and especially
    in [[*Meeting timing constraints]], we have not been able to deploy our router
    to routinely handle real traffic.
    Solving those problems, or porting our implementation to a target with a
    less broken toolchain, would let us do that, and therefore be the ultimate
    test for our implementation, as well as enable us to reap the benefits of
    the high-speed router in production.
*** DONE Adding COLIBRI and EPIC
    CLOSED: [2019-07-24 Wed 16:11]
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    While "plain SCION" is already a significant improvement over today's
    Internet, features built on top of it could provide even more benefits.
    Examples of such systems are COLIBRI, a system for bandwidth reservation
    that guarantees bandwidth even in the face of network overload and DDoS
    attacks, and EPIC, a source authentication mechanism that can run at line
    rate.

    It would be interesting to see how it would go to implement these more
    complex schemes in hardware, and whether line rate can still be achieved
    without unreasonable costs.
*** DONE Power requirements optimisation
    CLOSED: [2019-07-24 Wed 16:12]
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    In theory, not requiring large tables decreases the chip area and therefore
    its power consumption.
    However, the added cryptographic verification of every packet is a complex
    operation that may increase it.
    It has been theoretically predicted TODO citation that SCION may be able to
    use overall less energy per packet, but measuring it and seeing it in
    practice would be much more tangible.
    Moreover, with a hardware design, we may be able to look for opportunities
    for further energy requirements optimisation.
    Costs of running network equipment are nowadays largely due to electricity,
    plus there are environmental concerns to consider, and therefore an
    exploration of SCION's power requirements would be very valuable.
*** TODO Other high-speed SCION applications
    :PROPERTIES:
    :UNNUMBERED: t
    :END:
    other potential uses for my "SCION as a library": e.g. smart NICs with P4 in them => very fast end hosts
* [0/1] Conclusion
  # Bring it back to the big picture. How do your results fit into the current body of knowledge?
  # Most importantly, how can these results help you ask better questions?
  - high-security Internet protocols, and especially SCION, can feasibly be forwarded at high speeds
  - we see no major obstacles for implementing a very high throughput thingy
    (order of Tbps), and the minor things are going to be cleared up with the
    data plane redesign that incorporates my suggestions
  - P4 is an adequate language and though not everything is perfect, it is a
    useful tool that indeed helps achieve a quicker development cycle
  - we are looking forward to having more mature HW targets and toolchains, and
    we think there is much promise in continuing this work with those


#+LATEX: \bibliographystyle{abbrv}
bibliography:bibliography.bib

#+LATEX: \appendix

* Footnotes

[fn:8] For context, the Virtex 7 FPGA present in the NetFPGA is often used for prototyping CPUs. To fill it up is a rather unexpected feat.

[fn:7] The P4-NetFPGA design includes a full Microblaze microprocessor in the FPGA. This alone takes up about 30% of the FPGA area.

[fn:6] The FWD_ONLY FLAG can be used by the AS to indicate that this HF is only usable for forwarding to other ASes, not for local packet delivery.

[fn:5] SCION Control Message Protocol: the equivalent of ICMP in SCION. These packets should be rate-limited, and in future versions of SCION, they may become source-authenticated (i.e. require additional crypto).

[fn:4] In addition to "standard SCION", SCION also supports packets with end-to-end bandwidth reservations, and source-authenticated packets. For these, the verification information is different. In this work, we only implement the "standard SCION" mode, and will mention the other modes only very briefly.

[fn:3] Autonomous System: a network or collection of networks that managed and supervised by a single entity or organization. An ISP's network is an example of an AS.

[fn:2] Application-specific integrated circuit: an integrated circuit customized
for a particular use. Since ASICs are custom-built, they can be highly
cost-effective and energy-efficient, assuming a sufficiently large deployment.

[fn:1] Field-programmable gate array: a chip with many programmable logic blocks
and programmable interconnects that can be used for hardware prototyping.

# Local Variables:
# org-confirm-babel-evaluate: (lambda (lang body) (not (string= lang "emacs-lisp")))
# after-save-hook: org-latex-export-to-latex
# End:
