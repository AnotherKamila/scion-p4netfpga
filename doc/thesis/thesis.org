#+TITLE:  Line-rate packet forwarding for the SCION future Internet architecture
#+AUTHOR: Kamila Součková
#+DATE:   August 19, 2019
#+INCLUDE: thesis-setup.org

* [1/1] Abstract
  CLOSED: [2019-07-15 Mon 15:45]
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
The SCION future Internet architecture is designed to provide route control,
failure isolation, and explicit trust information for end-to-end communication.
Its viability has already been demonstrated in production, but to work
at Internet scale, it is necessary to make it perform at high speeds, reduce
costs, and evaluate suitability for eventual implementation in hardware.
This project implements a SCION border router capable of line-rate packet
forwarding, currently running on an FPGA target.
It uses P4: a new language for programming packet forwarding planes.
This enables target independence, a quicker development cycle, and a more
modular approach.
Based on this work, we suggest changes to the SCION data plane that allow for
more efficient processing in hardware.
* [1/3] Introduction
  What is SCION and why?
  What problems is SCION trying to solve?
  What problems is my thingy trying to solve?
  Why is it interesting?
  # [In field X, we still don’t understand Y & Z.]
  #
  # Write a summary of the question(s) you are trying to answer.
  # What is the state of the world before your research came along?
  # Also, answer the harsh but important question: Who cares?
  #
  # In writing this, you can start general, but make sure you clearly define the “before” state of the world’s knowledge for the specific area this paper is addressing.
*** DONE Why SCION?
    CLOSED: [2019-07-16 Tue 15:25]
    Today's Internet, based on IP and BGP, was conceived in a very different
    environment, with very different requirements and very different
    assumptions. Meant to be a research network, it assumed that
    access was not widespread (as only large institutions could afford a
    connection), that all entities connected to it trusted each other (and had
    out-of-band means to deal with misbehaviour),
    and that it would not grow large enough for outages to become difficult to
    manage.
    Considering these facts, it has scaled surprisingly well, but nowadays we
    are living in a very different world.

    Today, everyone is connected and everyone has their data on the Internet.
    With the huge number of connected entities, many of which have conflicting
    interests, trust can no longer be global and implicit.
    Users want control over their data, ISPs want control over their services,
    and states want to protect their infrastructure from outside actors.
    At this scale, convergence after path failure takes too long, and
    large-scale outages due to BGP route leaks are happening almost weekly.
    Furthermore, attacks on the Internet infrastructure, e.g. DDoS attack or BGP
    route hijacks, are becoming more and more common.
    In today's world, these issues can no longer be tolerated.

    In the future, the Internet will become even more critical. Automation (such
    as drones, self-driving cars, or remotely operated robots) will depend on
    the availability and security of the Internet.
    As more and more data moves online, trust will become even more of an issue.
    We will need ways to satisfy new requirements such as geofencing, which
    cannot be adequately fulfilled with the current Internet architecture.
    And as malicious actors get more and more sophisticated and powerful, their
    attacks will get even harder to stop.
    Therefore, we will need to move to an Internet architecture that is
    resilient to both unintentional failures and malicious attacks,
    can provide explicit trust information to the end users,
    and gives the end users as well as institutions control over whom they trust
    and what happens with their data.

    There have been may attempts to fix the IP+BGP-based Internet TODO[cite
    something], but patching an architecture designed with entirely different
    assumptions simply cannot solve all the problems TODO[cite something].
    Additionally, the IP-based approach also has scalability issues due to
    requiring very large routing tables, and this is bound to get worse in the
    future.
    Therefore, the SCION project chooses to build a clean-slate Internet
    architecture, with the goals of scalability, route control, failure
    isolation, and explicit trust information in the design.
*** INPR SCION right now
    Thanks to a well-thought-out design, as well as "real-life" considerations
    such as deployment, transition strategy, and engagement with industry, SCION
    is currently running in production in several locations TODO[cite].
    Additionally, a planet-wide research network for testing SCION is running
    thanks to SCIONLab TODO[cite SCIONLab paper].
    These use cases have proven that SCION is in fact suitable for real-world
    usage.
    In the near future, several ISPs will start offering SCION connections to
    their customers.
    Therefore, considerations like throughput, cost-effectiveness, and energy
    efficiency are of great interest to many in the SCION community.

    The existing implementations of the SCION infrastructure, in particular the
    routers, run as applications on standard servers. This has enabled rapid
    development, as well as flexibility, and it will continue to be the primary
    approach until the protocol stabilises.
    However, with the current technologies, a software-based approach cannot
    achieve throughput above several tens of gigabits per second.
    Therefore, large-scale deployments would require many such routers, which is
    not cost-effective.
    Additionally, whether SCION can even in principle run at line rate is still
    an open question.

    Especially thanks to the real-world deployments, SCION is now
    mature enough to start looking into implementing it in hardware.
    Though the current version of the protocol is very unlikely to be the final
    one, it would be useful to get an initial hardware-based implementation,
    mainly in order to evaluate the protocol's suitability for hardware.
    A successful hardware implementation would also be a good answer to the "can
    it run at line rate?" question, which would further increase the probability
    of deployment with commercial ISPs.
*** Building a high-speed SCION router in hardware
    We are going to solve this problem by...
    providing a high-speed, modular and extensible FPGA-based border router that can forward SCION really fast.
    TODO ^ This is the point of the introduction. Make it stand out.
* [0/4] Background and Related Work
P4 and NetFPGA and SCION and what we’re working with and what we’re trying to achieve and related work and stuff.
# [We have here method A, B, and our new method C.]
#
# You have established the core question(s) of your research.
# Now introduce the tools you are going to use to understand it.
*** TODO SCION
***** Overview of the SCION architecture
***** What exactly are we trying to solve, in relation to above?
***** Why are we doing it?
***** Related work
*** TODO High-speed packet forwarding
*** TODO P4
    this is a tool for solving above => relate this to that
*** TODO NetFPGA
    this is a tool for solving above => relate this to that
* [0/4] Aims
*** TODO Deployable SCION BR
    - forwarding at line rate => with NetFPGA, that is 40Gbps
    - usable with real traffic
    - integrated with existing SCION infra (control plane, monitoring/metrics)
*** TODO SCION as a library
*** TODO Guidelines for high-speed P4
    or gaining experience or whatevs
    Listen to my advice and you too can process packets at high speeds, even if you are not a hardware person.
*** TODO Optimising the SCION protocol for HW
* [0/1] Design overview
  this section is essentially just a diagram of the components

  show pic with data plane + normal SCION SW router + my thin control plane

  this is awesome because:
  - simplicity: everything that doesn't have to happen at line rate, such as error packet generation, all control plane packet processing, even ARP and stuff, is handled transparently without any work on my side
  - "upgradeability": if the control plane gets extended / changed, I don't care, as long as the forwarding path format (which isn't as likely to change) is the same
  - enables incremental development of the HW design: start with just passing through everything, then add more and more features that don't have to go to CPU
* [0/7] Implementation Challenges
  # originally wanted to divide this into parser, validation, forwarding, etc... but
  # I don't think that makes much sense, as e.g. timing or stupid compiler were a
  # problem across the whole thing
*** TODO Target independence
*** TODO Incremental development
***** fake network interfaces over DMA
***** control plane
      twisted => trivially composable => trivial to add new features, mix&match
*** TODO Control plane
    independent modules, often complementary to the P4 modules => something something modularity runs across the whole stack
      Perhaps also TODO have a look at my P4 presentation. Maybe there's something good in it :D // plagiarising myself
      Design decision: Using registers rather than digest packets so that I can do that transparent software router trick super easily.
******* What was horrible:
        existing Python control plane API sucked, so I rolled my own
        - tables: bugs in interpretation of the values
        - everything was hard-coded
        - only 32-bit registers supported, but that goes all the way to the C API and the bus
*** TODO Implementing the parser
    Things that were horrible here (TODO write how I solved them!):
    - var length shit
    - reject behaving contrary to even the NetFPGA devs' expectation (TODO link to issue)
    - timing
***** the funny 5-stage story
      (include deparser here, because this is the reason why deparser was interesting)

      1. P4 has header stacks, gonna use header stacks.
      2. Header stacks not supported. => Stick the parts of the path before and after the current HF into a varbit thing.
      3. varbit not supported. => Skip the bits and use `XilinxStreamSwitch` to not lose them on the other end.  
         * explain changing template?
      4. Even skipping sizes that aren't compile-time constants not supported. => Loop in the parser (cycle in the state machine)
      5. Weird compiler bug on cycles (generates invalid sdnet code) => Unroll the loop and create $K$ separate states for parsing paths long $1...K$.
      5. Doesn't build for K > 16. => Do my $\sqrt{K}$ two-stage thing.
         => Show spacetime before & after.
***** the final design
      parser state machine diagram
*** TODO Hop field MAC validation
***** MAC
      adding extern (pipelined! <-- took forever to find out)

      Specifically, SCION uses the AES-CMAC function as specified by RFC 4493. It needs to MAC at most 2 at most 256-bit blocks per packet, which translates to  AES-128-ECB computations per packet.
***** timestamp
      just write clock by control plane
*** TODO Working around compiler/toolchain bugs
    unfortunately, this was enough of an issue to warrant a separate section in this thesis

*** TODO Meeting timing constraints
      - TODO example of data dependency graph and how I optimised it
* [0/4] Results
  What am I supposed to put here here?
  Ideally: It's effing fast and it's running in production :D And here are the pictures about how effing fast it is. Also about timing and utilisation and perhaps power consumption.
  # > What happened (objectively)?
  # > Do not interpret, simply state the facts.
  # > Let's be honest: the first thing most of us do when skimming a paper is look at the figures. If your key results can be presented in figures, then start with that, and structure your paper around that.
*** TODO Throughput
    pretty much my magic dashboard
    (include queue sizes)
*** TODO Latency
    if I can
*** TODO Fraction of real traffic sent to CPU
*** TODO Resource usage
    ideally also per-component
***** TODO FPGA area
***** TODO Power consumption
* [0/4] Discussion
  # > Results are objective, but science isn't about listing data, it's about extracting meaning from what we observe.
*** TODO Why do we see the results we see?
    TODO what do we see? :D
    Because this is "SCION as a library", I should talk not just about the BR's performance, but also about the characteristics of the parts on their own.
*** TODO Guidelines for high-speed packet processing
***** Intro to FPGAs for software people
******* think in space, not time
        - everything happens at the same time
        - TODO didn't I start writing this down somewhere else? either tiddlywiki or website :D -- find it!
******* resources / limiting factors
        - Area instead of # of instructions
        - Timing => path length + logic complexity
******* [0/2] Concepts:
        TODO but but but this should go way earlier because I'm referring to these all the time
        I suppose they should go to [[*Background and Related Work]]?
********* TODO FPGA area
********* TODO Timing constraints

***** insights about P4 => HDL translation
******* Timing
        - inout parameters correspond to long paths => timing problems
        - CAM tables are kinda expensive (~0.1ns)
        - TODO how to find the critical path?
        - example of data dependency graph and optimising it
*** TODO Implications for the SCION protocol
    TODO this is a bit complicated... I am providing suggestions, but the actual
    things that will make it to the next version of SCION aren't my work, they are
    someone else's work that takes into account my suggestions. How do I put that
    here?
***** TODO What SCION does right
******* Avoiding lookup tables
        show area of a CAM table
        and if I have too much free time, do a power consumption measurement
***** TODO What should be improved
******* TODO Defining maximum sizes
        Currently, the maximum path length in the packet header is unreasonably
        large (the 8-bit offset fields allow for up to 256*8 = 2kB offset), and
        the hop field length is virtually unlimited (the continue flag signals
        whether we need to keep reading, and there is no maximum length defined).
        In hardware, in order to enable pipelining, we need to create buffers of
        the "worst case" size.
        This consumes FPGA area (thereby increasing costs and possibly energy
        consumption) and, due to processing in fixed-size blocks, increases
        latency.
        Therefore, these should be limited. We propose the following:
        - limiting the maximum number of hops to some "reasonable" value, such as 64
        - limiting the maximum hop field size to e.g. 16 bytes
******* TODO Avoiding variable lengths
        - good: pad to a nice number (currently 8, in the future SCION will pad to 4)
        - ATM HFs can be any multiple of 8 bytes, in the future (thanks to the
          change to 4 bytes) SCION will have only 12-byte HFs
******* TODO Avoiding implicit lengths
        addr type
******* TODO Consider re-thinking MAC chaning for peering paths
        In the case of peering paths, bla TODO bla
*** TODO what else have we learned?
* [0/6] Future work
*** TODO Completing the feature set
*** TODO Higher throughput
    terabit router
*** TODO Running in production
*** TODO Adding COLIBRI and EPIC
*** TODO Power requirements optimisation
*** TODO Other high-speed SCION applications
    other potential uses for my "SCION as a library": e.g. smart NICs with P4 in them => very fast end hosts
* [0/1] Conclusion
  # Bring it back to the big picture. How do your results fit into the current body of knowledge?
  # Most importantly, how can these results help you ask better questions?
  - high-security Internet protocols, and especially SCION, can feasibly be forwarded at high speeds
  - we see no major obstacles for implementing a very high throughput thingy
    (order of Tbps), and the minor things are going to be cleared up with the
    data plane redesign that incorporates my suggestions
  - P4 is an adequate language and though not everything is perfect, it is a
    useful tool that indeed helps achieve a quicker development cycle
  - we are looking forward to having more mature HW targets and toolchains, and
    we think there is much promise in continuing this work with those
